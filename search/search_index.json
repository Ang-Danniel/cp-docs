{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Selamat Datang","text":"<p>Ini adalah dokumentasi untuk Pemrograman Kompetitif Danniel.</p> <p>Di sini berisi topik-topik pemrograman kompetitif+ serta solusi dan penjelasan untuk berbagai soal pemrograman kompetitif.</p> <ul> <li>Dasar C++: Sintaks, struktur data, algoritma, dan praktik umum.</li> <li>Topik-topik Pemrograman Kompetitif: TBA</li> <li>Penyelesaian Soal: TBA</li> </ul> <p>Silakan jelajahi sesuai kebutuhan.</p>"},{"location":"Editorial/Post%20Test%20LOPI%202025/01-bintang-ojol/","title":"Bintang Ojol","text":"<p>Link Soal: Penyisihan CPC Senior - Bintang Ojol Sumber: Penyisihan CPC Senior / TLX Tingkat Kesulitan: Easy Tag: Greedy, Math</p>"},{"location":"Editorial/Post%20Test%20LOPI%202025/01-bintang-ojol/#overview-permasalahan","title":"Overview Permasalahan","text":"<p>Diberikan N dan M sebagai input dimana N adalah banyak bintang total yang akan di distribusikan ke M Ojol. Tentukan banyak Ojol maksimum dan minimum yang menerima bintang 5!</p>"},{"location":"Editorial/Post%20Test%20LOPI%202025/01-bintang-ojol/#hints","title":"Hints","text":"Hint 1 <p>Perhatikan constraint yang diberikan, sudah tidak mungkin untuk membuat solusi dalam linear time!</p> Hint 2 <p>Jika anda ingin meminimumkan banyak ojol berbintang 5 maka anda harus membuang bintang sebanyak mungkin.</p>"},{"location":"Editorial/Post%20Test%20LOPI%202025/01-bintang-ojol/#solusi","title":"Solusi","text":"Solusi <p>Perhatikan jika kita ingin memaksimalkan banyak ojol berbintang 5, kita dapat mengawali seluruh ojol dengan bintang 1 kemudian membagi rata bintang 4 yang ada dengan pembagian biasa.  </p> <p><code>jawaban = (banyak_bintang - banyak_ojol) / 4;</code></p> <p>Sementara untuk meminimalkan, kita dapat membuat semua ojol berbintang 4 dan kemudian mendistribusikan bitang 1 yang tersisa.</p> <p><code>jawaban = banyak_ojol - (banyak_bintang / 4);</code></p> <ul> <li>Time Complexity: O(1)</li> <li>Space Complexity: O(1)</li> </ul>"},{"location":"Editorial/Post%20Test%20LOPI%202025/01-bintang-ojol/#implementasi","title":"Implementasi","text":"Implementasi Solution<pre><code>ll n, m; cin &gt;&gt; n &gt;&gt; m;\nll minn, maxx;\nminn = maxx = -1;\n\nif(!(m * 5ll &lt; n || n &lt; m)){ // Cek apakah bintang tidak dapat atau melebihi dari yang bisa didistribusikan\n    ll nt;\n    nt = n;\n    nt -= m;\n    maxx = nt / 4ll; \n\n    if(n &lt;= 4ll * m){\n        minn = 0;\n    }else{\n        minn = n - (4ll * m);\n    }\n}\ncout &lt;&lt; minn &lt;&lt; \" \" &lt;&lt; maxx;\n</code></pre> <p>:3</p>"},{"location":"Editorial/Post%20Test%20LOPI%202025/02-plus-minus/","title":"Plus Minus","text":"<p>Link Soal: TLX TOC 2017 OCT 2B Sumber: TOC 2017 / TLX Tingkat Kesulitan: Easy Tag: Math/DP</p>"},{"location":"Editorial/Post%20Test%20LOPI%202025/02-plus-minus/#overview-permasalahan","title":"Overview Permasalahan","text":"<p>Diberikan persamaan _ 1 _ 2 _ ... N-1 = N. Kita perlu menentukan apakah ada kemungkinan tertentu sehingga persamaan tersebut valid. </p> <p>N hanya berkisar dari 1 hingga 100 (inklusif).</p>"},{"location":"Editorial/Post%20Test%20LOPI%202025/02-plus-minus/#hints","title":"Hints","text":"Hint 1 <p>Buatlah hasil untuk N = 1 hingga N = 8. Lakukan percobaan.</p> Hint 2 <p>Asumsikan semua operatornya + terlebih dahulu kemudian sesuaikan.</p>"},{"location":"Editorial/Post%20Test%20LOPI%202025/02-plus-minus/#solusi","title":"Solusi","text":"Solusi <p>Mari kita gunakan contoh ketika N = 4 dan asumsikan bahwa seluruh operator adalah plus. Maka total persamaan kiri adalah <code>3 (4) / 2 = 6</code>, Bila kita mengubah suatu tanda dari salah satu operator yang ada maka total persamaan kiri akan berkurang sebanyak 2 kali dari bilangan yang dirubah ke negatif.</p> <p>Sebagai contoh + 1 + 2 + 3 = 6 Bila kita mengubah + 1 menjadi - 1 maka - 1 + 2 + 3 = 4 Atau dalam kata lain berkurang sebanyak 2 * 1 (dimana 1 adalah bilangan yang diubah ke negatif)</p> <p>Kesimpulannya adalah kita dapat mengurangi sebanyak bilangan genap saja. Sehingga bila kedua (N * (N - 1) / 2) dan N tidak ganjil atau genap, maka tidak mungkin untuk membuat persamaan tersebut!</p> <p>Sementara jika keduanya genap atau ganjil, kita dapat selalu pasti menemukan suatu kombinasi pengurangan sehingga kita menjelajahi setiap kemungkinan ganjil dan genap yang mungkin.</p> <p>Misal pada contoh N = 4 + 1 + 2 + 3 = 6 - 1 + 2 + 3 = 4 + 1 - 2 + 3 = 2 + 1 + 2 - 3 = 0 dst</p> <ul> <li>Time Complexity: O(1)</li> <li>Space Complexity: O(1)</li> </ul>"},{"location":"Editorial/Post%20Test%20LOPI%202025/02-plus-minus/#implementasi","title":"Implementasi","text":"Implementasi Solution<pre><code>int n; cin &gt;&gt; n;\nif (n % 4 == 1) cout &lt;&lt; \"TIDAK\";\nelse if (n % 4 == 2) cout &lt;&lt; \"TIDAK\";\nelse cout &lt;&lt; \"YA\";\n</code></pre> <p>:3</p>"},{"location":"Editorial/Post%20Test%20LOPI%202025/03-plus-or-times/","title":"Plus or Times","text":"<p>Link Soal: INC 2022 - Problem G Sumber: INC 2022 / TLX Tingkat Kesulitan: Medium  Tag: DP</p>"},{"location":"Editorial/Post%20Test%20LOPI%202025/03-plus-or-times/#overview-permasalahan","title":"Overview Permasalahan","text":"<p>Terdapat sebuah permainan dimana anda ingin initial point anda yaitu p menjadi semaksium mungkin dengan mengikuti beberapa ronde permaianan.</p> <p>Disetiap rondenya anda ingin mengubah point p yang anda miiliki sekarang dengan melakukan salah satu operasi yang ada.</p> <p>Tiap ronde akan terdapat 2 operasi yang dimana operasi tersebut bisa tambah atau pekalian dengan suatu bilangan. </p> <p>Anda wajib memilih satu operasi yang ada ke poin yang anda miliki. Tentukan p maksimum yang bisa anda raih.</p>"},{"location":"Editorial/Post%20Test%20LOPI%202025/03-plus-or-times/#hints","title":"Hints","text":"Hint 1 <p>Anda bisa melakukan DP disini :3.</p>"},{"location":"Editorial/Post%20Test%20LOPI%202025/03-plus-or-times/#solusi","title":"Solusi","text":"Solusi <p>Anggap maxx[i] sebagai nilai paling maksimum P jika terdapat i ronde saja dan minn[i] sebagai nilai paling minimum P jika terdapat i ronde saja. </p> <p>Maka perhatikan bahwa maxx[i] bisa didapatkan dengan maxx[i-1] dan minn[i-1] saja. Hal ini benar karena dengan nilai paling minimum p dapat menjadi nilai paling maksimum jika minn[i-1] negatif dan terdapat operasi kali negatif yang dapat membuat menjadi nilai negatif yang besar.</p> <p>Sehingga <code>maxx[i] = max(minn[i-1] op1 c1, maxx[i-1] op1 c1);</code> <code>maxx[i] = max(maxx[i], maxx[i-1] op2 c2);</code> <code>maxx[i] = max(maxx[i], minn[i-1] op2 c2);</code></p> <p><code>minn[i] = min(minn[i-1] op1 c1, maxx[i-1] op1 c1);</code> <code>minn[i] = min(minn[i], maxx[i-1] op2 c2);</code> <code>minn[i] = min(minn[i], minn[i-1] op2 c2);</code></p> <ul> <li>Time Complexity: O(N)</li> <li>Space Complexity: O(1)</li> </ul>"},{"location":"Editorial/Post%20Test%20LOPI%202025/03-plus-or-times/#implementasi","title":"Implementasi","text":"Implementasi Solution<pre><code>ll n, p; cin &gt;&gt; n &gt;&gt; p;\nll maxx, minn;\nmaxx = minn = p;\nfor (int i = 0; i &lt; n; i++) {\n    char op; cin &gt;&gt; op;\n    ll input; cin &gt;&gt; input;\n    ll tempMax1, tempMin1;\n    if (op == '+') {\n        tempMax1 = maxx + input;\n        tempMin1 = minn + input;\n    } else {\n        tempMax1 = maxx * input;\n        tempMin1 = minn * input;\n    }\n\n    cin &gt;&gt; op;\n    cin &gt;&gt; input;\n    ll tempMax2, tempMin2;\n    if (op == '+') {\n        tempMax2 = maxx + input;\n        tempMin2 = minn + input;\n    } else {\n        tempMax2 = maxx * input;\n        tempMin2 = minn * input;\n    }\n\n    maxx = max(tempMax1, tempMax2);\n    maxx = max(maxx, tempMin2);\n    maxx = max(tempMin1, maxx);\n\n    minn = min(tempMax1, tempMax2);\n    minn = min(tempMin1, minn);\n    minn = min(minn, tempMin2);\n}\ncout &lt;&lt; maxx &lt;&lt; endl;\n</code></pre> <p>:3</p>"},{"location":"Editorial/Post%20Test%20LOPI%202025/04-organisasi-kemahasiswaan/","title":"Organisasi Kemahasiswaan","text":"<p>Link Soal: Gemastik Final 2017 - Problem A Sumber: Gemastik Final 2017 / TLX Tingkat Kesulitan: Medium Tag: Math, Number Theory</p>"},{"location":"Editorial/Post%20Test%20LOPI%202025/04-organisasi-kemahasiswaan/#overview-permasalahan","title":"Overview Permasalahan","text":"<p>Terdapat N organisasi kemahasiswaan di Fasilkom UI. Organisasi ke-i terdiri atas tepat M[i] mahasiswa. Menurut peraturan fakultas, setiap mahasiswa hanya boleh tergabung pada paling banyak K organisasi.</p> <p>Berapakah banyaknya mahasiswa Fasilkom UI paling sedikit yang mungkin?</p>"},{"location":"Editorial/Post%20Test%20LOPI%202025/04-organisasi-kemahasiswaan/#hints","title":"Hints","text":"Hint 1 <p>Banyak mahasiswa minimum adalah M[i] paling maksimum.</p> Hint 2 <p>Buatlah tabel dimana mahasiswa merepresentasikan kolom dan baris merepresentasikan organisasi mahasiswa kolom i ikuti.</p>"},{"location":"Editorial/Post%20Test%20LOPI%202025/04-organisasi-kemahasiswaan/#solusi","title":"Solusi","text":"Solusi <p>P Perhatikan jika banyak mahasiswa adalah sebanyak T maka persamaan T * K &gt;= Sumasi(M[i]) haruslah terpenuhi. T juga harus &gt;= M[i] paling maksimum.</p> <p>Menurut PHP, hanya ketika T * K &lt; Sumasi(M[i]) terdapat mahasiswa yang mengikuti lebih dari K organisasi. Untuk memudahkan visualisasi kamu dapat mengganggap T * K adalah sebuah tabel dimana mahasiswa merepresentasikan kolom dan baris merepresentasikan organisasi mahasiswa kolom i ikuti.</p> <p>Bila masukan: <pre><code>1\n7 4\n2 3 4 5 6 7 8\n</code></pre></p> <p>Contoh tabel distribusi mahasiswa ke organisasi (misal T = 8, K = 4, M = [3, 3, 4, 5, 6, 7, 8]):</p> Organisasi Mahasiswa ke-1 Mahasiswa ke-2 Mahasiswa ke-3 Mahasiswa ke-4 Mahasiswa ke-5 Mahasiswa ke-6 Mahasiswa ke-7 Mahasiswa ke-8 Mahasiswa ke-9 Org ke-1 7 7 7 7 7 7 7 7 6 Org ke-2 6 6 6 6 6 6 5 5 5 Org ke-3 5 5 5 4 4 4 4 4 4 Org ke-4 3 3 3 3 2 2 2 1 1 <p>Dapat dilihat bahwa tidak ada mahasiswa yang organisasi nya overlap karena banyak kolom lebih dari M[i] paling maksimum. Jadi kita cukup mencari nilai T dimana T = ceil(Sumasi(M[i]) / K) dan T harus lebih besar dari M[i] paling maksimum.</p> <ul> <li>Time Complexity: O(1)</li> <li>Space Complexity: O(1)</li> </ul>"},{"location":"Editorial/Post%20Test%20LOPI%202025/04-organisasi-kemahasiswaan/#implementasi","title":"Implementasi","text":"Implementasi Solution<pre><code>ll n, k; cin &gt;&gt; n &gt;&gt; k;\n\nll sum = 0;\nll maxx = 0;\nfor (int i = 0; i &lt; n; i++){\n    ll temp; cin &gt;&gt; temp;\n    sum += temp;\n    maxx = max(maxx, temp);\n}\n\nll ans = (sum / k);\nif (sum % k != 0) ans++;\nans = max(maxx, ans);\ncout &lt;&lt; ans &lt;&lt; endl;\n</code></pre>"},{"location":"Editorial/Post%20Test%20LOPI%202025/05-berbagi-lawakan/","title":"Berbagi Lawakan","text":"<p>Link Soal: Gemastik 17 - Problem I Sumber: TROC / TLX  Tingkat Kesulitan: Hard Tag: Graph, BFS</p>"},{"location":"Editorial/Post%20Test%20LOPI%202025/05-berbagi-lawakan/#overview-permasalahan","title":"Overview Permasalahan","text":"<p>Jelaskan permasalahan secara singkat dan jelas. Apa yang diminta dalam soal? Apa input dan output yang diharapkan?</p> <p>Contoh: - Input: Deskripsi format input - Output: Deskripsi format output - Constraints: Batasan-batasan yang diberikan</p>"},{"location":"Editorial/Post%20Test%20LOPI%202025/05-berbagi-lawakan/#hints","title":"Hints","text":"Hint 1 <p>Sebuah lawakan abadi bila terdapat siklus yang terdiri dari pelawak-pelawak yang menyukai lawakan tersebut.</p> Hint 2 <p>Untuk mencari sebuah siklus, Anda dapat menggunakan DFS seperti pada artikel berikut (Cycle Detection).    </p>"},{"location":"Editorial/Post%20Test%20LOPI%202025/05-berbagi-lawakan/#solusi","title":"Solusi","text":"Solusi <p>Untuk menentukan apakah sebuah lawakan dapat menjadi abadi, kita perlu mencari apakah terdapat jalur menuju sebuah siklus yang terdiri dari pelawak-pelawak yang menyukai lawakan tersebut. Hal ini dapat dilakukan dengan melakukan DFS yang dimulai dari suatu node dan membentuk path menuju node lain. Jika node berikutnya yang akan dikunjungi sudah terdapat dalam path DFS saat ini, maka seluruh node pada path tersebut dapat dianggap mampu membuat lawakan yang dimulai dari node tersebut menjadi abadi.</p> <p>Namun ini saja tidak cukup, kita perlu mengoptimasi setiap pertanyaan yang diberikan dimana kita dapat menggunakan array sebesar 100 \u00d7 50000 untuk menampung informasi dari tiap node, atau memproses seluruh pertanyaan dari yang nilai humornya paling rendah ke paling besar.</p> <ul> <li>Time Complexity: O(M + N + Q)</li> <li>Space Complexity: O(M + N)</li> </ul>"},{"location":"Editorial/Post%20Test%20LOPI%202025/05-berbagi-lawakan/#implementasi","title":"Implementasi","text":"Implementasi Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n#include &lt;algorithm&gt;\n#include &lt;cmath&gt;\n#include &lt;map&gt;\n#include &lt;set&gt;\n#include &lt;stack&gt;\n#include &lt;queue&gt;\n#include &lt;deque&gt;\n#include &lt;bitset&gt;\n#include &lt;iomanip&gt;\n#include &lt;complex&gt;\n#include &lt;numeric&gt;\n#include &lt;climits&gt;\n#include &lt;cassert&gt;\n#include &lt;cstring&gt;\n#include &lt;chrono&gt;\n#include &lt;random&gt;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n#define pb push_back\n#define eb emplace_back\n#define ppb pop_back\n#define fi first\n#define se second\n#define ub upper_bound\n#define lb lower_bound\n#define pii pair&lt;int,int&gt;\n#define pll pair&lt;ll,ll&gt;\n#define rep(i,n) for (i = 0; i &lt; n; ++i)\n#define REP(i,k,n) for (i = k; i &lt;= n; ++i)\n#define REPR(i,k,n) for (i = k; i &gt;= n; --i)\nusing namespace std;\nconst ll MOD = 1e9 + 7;\n#define semoga_ac ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)\n\ntypedef complex&lt;double&gt; P;\n#define X real()\n#define Y imag()\ntypedef vector&lt;int&gt; vi;\ntypedef vector&lt;vi&gt; vvi;\n\nint a[50001];\nint b[50001];\n\nvector&lt;int&gt; adj[50001];\nbool ans[101][50001];\nbool vis[50001];\n\nbool temp[50001];\n\nvoid dfs(int cur, int h) {\n    vis[cur] = true;\n\n    if (!((a[cur] &lt;= h) &amp;&amp; (b[cur] &gt;= h))){\n        return;\n    }\n\n    temp[cur] = true;\n\n    for (auto v: adj[cur]) {\n        if (temp[v] &amp;&amp; (a[v] &lt;= h) &amp;&amp; (b[v] &gt;= h)) {\n            ans[h][cur] = true;\n        }\n\n        if(!vis[v] &amp;&amp; (a[v] &lt;= h) &amp;&amp; (b[v] &gt;= h)) {\n            dfs(v, h);\n        }\n\n        if (ans[h][v] &amp;&amp; (a[v] &lt;= h) &amp;&amp; (b[v] &gt;= h)) {\n            ans[h][cur] = true;\n        }\n    }\n    temp[cur] = false;\n}\n\nint main(){\nsemoga_ac;\n    int n, m; cin &gt;&gt; n &gt;&gt; m; \n\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; a[i];\n    }\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; b[i];\n    }\n\n    int u, v; \n    for (int i = 1; i &lt;= m; i++) {\n        cin &gt;&gt; u &gt;&gt; v;\n        adj[u].pb(v);\n    }\n\n    for (int i = 0; i &lt;= 100; i++) {\n        memset(vis, false, sizeof(vis));\n        for (int j = 1; j &lt;= n; j++) {\n            if (!vis[j]) dfs(j, i);\n        }\n    }\n\n    int q; cin &gt;&gt; q;\n    for (int i = 0; i &lt; q; i++) {\n        cin &gt;&gt; u &gt;&gt; v;\n        if(ans[v][u]) cout &lt;&lt; \"Ya\" &lt;&lt; endl;\n        else cout &lt;&lt; \"Tidak\" &lt;&lt; endl; \n    }\n}\n</code></pre>"},{"location":"Editorial/Post%20Test%20LOPI%202025/06-x-mas/","title":"X-Emas","text":"<p>Link Soal: X-Emas - Problem E Sumber: TROC / TLX Tingkat Kesulitan: Hard Tag: Binary Search, Prefix Sum</p>"},{"location":"Editorial/Post%20Test%20LOPI%202025/06-x-mas/#solusi","title":"Solusi","text":"Solusi <p>Pertama-tama, kita dapat mengurutkan tambang berdasarkan nilai Ai terbesar hingga terkecil. Untuk kegiatan menambang, kita hanya perlu memperhatikan tambang dengan nilai terbesar (Amax) dan terbesar kedua (Amax2). Sementara itu, untuk kegiatan mengebom, kita hanya perlu memperhatikan tambang yang memiliki nilai 2Ai &gt;= Amax2.</p> <p>Perhatikan bahwa urutan kegiatan menambang dan mengebom tambang emas tidaklah penting, karena di akhir kita dapat mengatur urutan kegiatan supaya memenuhi aturan. Kondisi yang perlu diperhatikan agar urutan kegiatan menambang dan mengebom memenuhi aturan adalah banyaknya penambangan Amax harus tidak lebih dari banyaknya pengeboman ditambah banyaknya penambangan Amax2.</p> <p>Untuk mendapatkan emas semaksimal mungkin, kita dapat memprioritaskan kegiatan menambang dan mengebom dengan urutan sebagai berikut:</p> <ol> <li>Mengebom seluruh tambang yang memiliki nilai 2Ai &gt;= Amax.</li> <li>Menambang tambang Amax sebanyak kegiatan mengebom yang dilakukan sebelumnya.</li> <li>Mengebom seluruh tambang yang memiliki nilai Amax &gt; 2Ai &gt;= Amax2, diselingi dengan menambang tambang Amax. Hati-hati: kegiatan mengebom harus didahulukan agar urutan kegiatan tetap memenuhi aturan.</li> <li>Menambang tambang Amax2 diselingi menambang tambang Amax. Hati-hati: kegiatan menambang tambang Amax2 harus didahulukan, dengan alasan yang sama seperti sebelumnya. Perhatikan juga kemungkinan overflow jika jumlah emas dihitung secara manual.</li> </ol> <p>Menentukan banyaknya hari minimum yang dibutuhkan untuk mendapatkan setidaknya X kilogram emas dapat dilakukan menggunakan binary search the answer (BSTA).</p> <p>Kompleksitas waktu: O(N(log N + log X)).</p> <p>Terdapat pula solusi tanpa BSTA yang bekerja dalam O(N log N).</p>"},{"location":"Editorial/Post%20Test%20LOPI%202025/06-x-mas/#implementasi","title":"Implementasi","text":"Implementasi Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n#include &lt;algorithm&gt;\n#include &lt;cmath&gt;\n#include &lt;map&gt;\n#include &lt;set&gt;\n#include &lt;stack&gt;\n#include &lt;queue&gt;\n#include &lt;deque&gt;\n#include &lt;bitset&gt;\n#include &lt;iomanip&gt;\n#include &lt;complex&gt;\n#include &lt;numeric&gt;\n#include &lt;climits&gt;\n#include &lt;cassert&gt;\n#include &lt;cstring&gt;\n#include &lt;chrono&gt;\n#include &lt;random&gt;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n#define pb push_back\n#define eb emplace_back\n#define ppb pop_back\n#define fi first\n#define se second\n#define ub upper_bound\n#define lb lower_bound\n#define pii pair&lt;int,int&gt;\n#define pll pair&lt;ll,ll&gt;\n#define rep(i,n) for (i = 0; i &lt; n; ++i)\n#define REP(i,k,n) for (i = k; i &lt;= n; ++i)\n#define REPR(i,k,n) for (i = k; i &gt;= n; --i)\nusing namespace std;\nconst ll MOD = 1e9 + 7;\n#define semoga_ac ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)\n\ntypedef complex&lt;double&gt; P;\n#define X real()\n#define Y imag()\ntypedef vector&lt;int&gt; vi;\ntypedef vector&lt;vi&gt; vvi;\n\nint main(){\n    semoga_ac;\n    int n; cin &gt;&gt; n;\n    ll x; cin &gt;&gt; x;\n\n    ll ar[n + 1];\n    vector&lt;ll&gt; prefBest;\n    for(int i = 0; i &lt;= n; i++) {\n        cin &gt;&gt; ar[i]; \n    }\n\n    sort(ar, ar + n);\n\n    ll best1 = ar[n - 1];\n    ll best2 = ar[n - 2];\n\n    ll sum = 0;\n    for (int i = n - 1; i &gt;= 0; i--) {\n        ll twoTimes = 2ll * ar[i];\n        if (twoTimes &gt;= best1) {\n            sum += twoTimes;\n            prefBest.pb(sum);\n        } else {\n            for(int j = n - 1; j &gt; i; j--) {\n                sum += best1;\n                prefBest.pb(sum);\n            }\n            for (int j = i; j &gt;= 0; j--) {\n                twoTimes = 2ll * ar[j];\n                if (twoTimes &gt;= best2) {\n                    sum += twoTimes;\n                    prefBest.pb(sum);\n                    sum += best1;\n                    prefBest.pb(sum);\n                } else {\n                    break;\n                }\n            }\n            break;\n        }\n\n        if (i == 0) {\n            for(int j = n - 1; j &gt; i; j--) {\n                sum += best1;\n                prefBest.pb(sum);\n            }\n        }\n    }\n\n    ll m = prefBest.size();\n    ll ans = 0;\n    if (prefBest[m - 1] &lt; x) {\n        x -= prefBest[m - 1];\n        ll sumBest = best1 + best2;\n        ans = m + (x / sumBest) * 2ll;\n        if (x % sumBest &lt;= best2) {\n            ans++;\n        } else if (x % sumBest &gt; best2) {\n            ans+=2;\n        }\n    } else {\n        int l, r, mid;\n        l = 0;\n        r = m - 1;\n        while (l &lt;= r) {\n            mid = (l + r) / 2;\n            if(prefBest[mid] &gt;= x) {\n                ans = mid + 1;\n                r = mid - 1;\n            } else {\n                l = mid + 1;\n            }\n        }\n    }\n\n    // for(int i = 0; i &lt; m; i++) cout &lt;&lt; prefBest[i] &lt;&lt; \" \";\n    // cout &lt;&lt; endl;\n    cout &lt;&lt; ans &lt;&lt; endl;\n}   \n</code></pre>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/01-perulangan/","title":"Perulangan","text":"<p>Perulangan (looping) merupakan konsep dasar yang sangat penting dalam pemrograman dan akan selalu muncul di berbagai soal kompetitif, mulai dari simulasi, iterasi array, perhitungan matematis, hingga teknik pencarian. Dengan memahami perulangan, kita dapat menulis kode yang efisien dan tidak berulang-ulang secara manual.</p>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/01-perulangan/#pengenalan","title":"Pengenalan","text":"<p>Mari kita mulai dengan contoh permasalahan sederhana:</p> <p>Cetak semua bilangan dari 1 hingga 100.</p> <p>Jika kita menulis: <pre><code>cout &lt;&lt; 1 &lt;&lt; endl;\ncout &lt;&lt; 2 &lt;&lt; endl;\n// ...\ncout &lt;&lt; 100 &lt;&lt; endl;\n</code></pre> Maka jelas, ini tidak efisien. Di sinilah perulangan dibutuhkan: kita bisa mengulang proses yang sama sebanyak 100 kali secara otomatis dengan satu baris kode.</p>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/01-perulangan/#for-loop","title":"For Loop","text":"<p>for loop digunakan saat kita mengetahui dengan pasti berapa kali perulangan akan dilakukan.</p> Struktur Umum<pre><code>for (inisialisasi; kondisi; perubahan) {\n    // blok kode\n}\n</code></pre> Mencetak 1 hingga 5<pre><code>for (int i = 1; i &lt;= 5; i++) {\n    cout &lt;&lt; i &lt;&lt; \" \";\n}\n// Output: 1 2 3 4 5\n</code></pre> <p>Kegunaan umum di pemrograman kompetitif:</p> <ul> <li>Mengambil n input</li> <li>Iterasi array/vector (Akan dipelajari di halaman berikutnya)</li> <li>Loop brute-force dengan batas n</li> </ul>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/01-perulangan/#flow-for-loop","title":"Flow For Loop","text":"<pre><code>flowchart LR\n    A[Mulai] --&gt; B[Inisialisasi]\n    B --&gt; C{\"Kondisi benar?\"}\n    C -- \"Tidak\" --&gt; F[Selesai]\n    C -- \"Ya\" --&gt; D[\"Eksekusi blok kode\"]\n    D --&gt; E[\"Increment/Decrement (opsional)\"]\n    E --&gt; C</code></pre> <p><code>for loop</code> sangat berguna ketika jumlah iterasi sudah diketahui sebelumnya. Dengan struktur yang ringkas, kita dapat mengontrol inisialisasi, kondisi, dan perubahan variabel dalam satu baris, sehingga kode menjadi lebih terorganisir dan mudah dibaca. </p> <p>Penggunaan <code>for loop</code> sangat umum dalam berbagai kasus, seperti mengakses elemen array, melakukan perhitungan berulang, dan menyelesaikan masalah yang membutuhkan iterasi dengan batas tertentu.</p> <p>Inisiasi</p> <p>Jika anda mendeklarasikan suatu variabel pada <code>inisiasi</code> di <code>for loop</code>. Variabel tersebut hanya akan dapat diakses pada <code>for loop</code> tersebut saja. Cek Variabel Scope C++ untuk dipelajari lebih lanjut.</p>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/01-perulangan/#while-loop","title":"While Loop","text":"<p>Digunakan ketika kita tidak tahu pasti berapa kali pengulangan dilakukan, dan hanya berhenti jika suatu kondisi tidak lagi terpenuhi.</p> Struktur Umum<pre><code>while (kondisi) {\n    // blok kode\n}\n</code></pre> Mencetak 1 hingga 5<pre><code>int i = 1;\nwhile (i &lt;= 5) {\n    cout &lt;&lt; i &lt;&lt; \" \";\n    i++;\n}\n// Output: 1 2 3 4 5\n</code></pre> <p>Kegunaan umum di pemrograman kompetitif:</p> <ul> <li>Perulangan dengan kondisi yang unik</li> <li>Simulasi dengan kondisi dinamis</li> <li>Beberapa algoritma umum seperti binary search menggunakannya</li> </ul>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/01-perulangan/#flow-while-loop","title":"Flow While Loop","text":"<pre><code>flowchart LR\n    A[Mulai] --&gt; B{\"Kondisi benar?\"}\n    B -- \"Tidak\" --&gt; E[Selesai]\n    B -- \"Ya\" --&gt; C[\"Eksekusi blok kode\"]\n    C --&gt; D[\"Increment/Decrement (opsional)\"]\n    D --&gt; B</code></pre> <p><code>while loop</code> sangat berguna ketika jumlah iterasi tidak diketahui sebelumnya dan perulangan bergantung pada kondisi tertentu. Loop ini akan terus berjalan selama kondisi bernilai benar, sehingga cocok untuk kasus di mana proses harus dilakukan hingga syarat tertentu tercapai. </p> <p>Infinite Loop</p> <p>Namun, pastikan kondisi pada <code>while</code> dapat menjadi salah agar tidak terjadi infinite loop.</p>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/01-perulangan/#do-while-loop","title":"Do-While Loop","text":"<p>do-while menjamin blok kode akan dieksekusi setidaknya satu kali, baru kemudian memeriksa kondisi.</p> Struktur Umum<pre><code>do {\n    // blok kode\n} while (kondisi);\n</code></pre> Mencetak 1 hingga 5<pre><code>int i = 1;\ndo {\n    cout &lt;&lt; i &lt;&lt; \" \";\n    i++;\n} while (i &lt;= 5);\n// Output: 1 2 3 4 5\n</code></pre>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/01-perulangan/#flow-do-while-loop","title":"Flow Do While Loop","text":"<pre><code>flowchart LR\n    A[Mulai] --&gt; B[\"Eksekusi blok kode\"]\n    B --&gt; C[\"Increment/Decrement (opsional)\"]\n    C --&gt; D{\"Kondisi benar?\"}\n    D -- \"Ya\" --&gt; B\n    D -- \"Tidak\" --&gt; E[Selesai]</code></pre> <p><code>do-while loop</code> memastikan blok kode dijalankan minimal satu kali sebelum kondisi diperiksa. Loop ini cocok digunakan jika proses harus dijalankan setidaknya sekali, misalnya untuk validasi input pengguna. Namun, dalam praktik pemrograman kompetitif, penggunaannya relatif jarang dibandingkan <code>for</code> dan <code>while loop</code>. Pilih <code>do-while</code> jika memang diperlukan eksekusi awal sebelum pengecekan kondisi.</p> <p>Pendapat Pribadi</p> <p>Jujur selama 4 tahun di pemrograman kompetitif, saya sendiri sangat amat jarang menggunakan ini. <code>do while</code> hanya while loops yang pasti dijalankan setidaknya 1 kali.</p>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/01-perulangan/#break-dan-continue","title":"Break dan Continue","text":"<p>Dalam perulangan, kita sering kali ingin mengontrol alur eksekusi di dalam loop. Dua perintah penting yang sering digunakan untuk tujuan ini adalah <code>break</code> dan <code>continue</code>.</p>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/01-perulangan/#break","title":"Break","text":"<p><code>break</code> digunakan untuk menghentikan perulangan secara paksa, meskipun kondisi loop masih terpenuhi. Biasanya digunakan ketika kita sudah menemukan apa yang dicari atau ingin keluar dari loop lebih awal.</p> Contoh penggunaan break<pre><code>for (int i = 1; i &lt;= 10; i++) {\n    if (i == 5) {\n        break; // keluar dari loop saat i == 5\n    }\n    cout &lt;&lt; i &lt;&lt; \" \";\n}\n// Output: 1 2 3 4\n</code></pre> <p>Pada contoh di atas, perulangan berhenti ketika <code>i</code> bernilai 5, sehingga hanya mencetak angka 1 sampai 4.</p>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/01-perulangan/#continue","title":"Continue","text":"<p><code>continue</code> digunakan untuk melewati sisa kode dalam satu iterasi dan langsung melanjutkan ke iterasi berikutnya. Biasanya dipakai jika ada kondisi tertentu yang ingin di-skip.</p> Contoh penggunaan continue<pre><code>for (int i = 1; i &lt;= 5; i++) {\n    if (i == 3) {\n        continue; // lewati iterasi saat i == 3\n    }\n    cout &lt;&lt; i &lt;&lt; \" \";\n}\n// Output: 1 2 4 5\n</code></pre> <p>Pada contoh di atas, angka 3 tidak dicetak karena saat <code>i == 3</code>, perintah <code>continue</code> membuat program langsung lanjut ke iterasi berikutnya.</p> <ul> <li><code>break</code> akan menghentikan seluruh loop.</li> <li><code>continue</code> hanya melewati satu iterasi, loop tetap berjalan.</li> <li>Keduanya bisa digunakan di semua jenis loop (<code>for</code>, <code>while</code>, <code>do-while</code>).</li> </ul> <p>Penggunaan <code>break</code> dan <code>continue</code> dapat membuat kode lebih ringkas dan mudah dibaca, terutama saat menangani kasus khusus di dalam perulangan.</p>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/01-perulangan/#nested-loop","title":"Nested Loop","text":"<p>Nested loop adalah perulangan di dalam perulangan, artinya sebuah loop berada di dalam blok kode loop lain. Konsep ini sangat penting untuk menyelesaikan masalah yang melibatkan data dua dimensi, seperti matriks, tabel, atau pola berbentuk grid. Struktur Nested Loop<pre><code>for (int i = 1; i &lt;= n; i++) {\n    for (int j = 1; j &lt;= m; j++) {\n        // blok kode yang dijalankan untuk setiap kombinasi i dan j\n    }\n}\n</code></pre></p> Contoh: Mencetak Matriks 3x3<pre><code>for (int i = 1; i &lt;= 3; i++) {\n    for (int j = 1; j &lt;= 3; j++) {\n        cout &lt;&lt; \"(\" &lt;&lt; i &lt;&lt; \",\" &lt;&lt; j &lt;&lt; \") \";\n    }\n    cout &lt;&lt; endl;\n}\n// Output:\n// (1,1) (1,2) (1,3) \n// (2,1) (2,2) (2,3) \n// (3,1) (3,2) (3,3) \n</code></pre>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/01-perulangan/#flow-nested-loops","title":"Flow Nested Loops","text":"<pre><code>flowchart LR\n    A[Mulai] --&gt; B[\"Inisialisasi loop luar (i)\"]\n    B --&gt; C{\"Kondisi loop luar benar?\"}\n    C -- \"Tidak\" --&gt; H[\"Selesai\"]\n    C -- \"Ya\" --&gt; D[\"Inisialisasi loop dalam (j)\"]\n    D --&gt; E{\"Kondisi loop dalam benar?\"}\n    E -- \"Tidak\" --&gt; G[\"Perubahan loop luar (i)\"]\n    G --&gt; C\n    E -- \"Ya\" --&gt; F[\"Eksekusi blok kode (i, j)\"]\n    F --&gt; I[\"Perubahan loop dalam (j)\"]\n    I --&gt; E</code></pre>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/01-perulangan/#kegunaan-nested-loop","title":"Kegunaan Nested Loop","text":"<ul> <li>Membuat pola (segitiga, persegi, dll)</li> <li>Mengakses elemen array 2 dimensi (matriks)</li> <li>Simulasi grid atau papan permainan</li> <li>Brute-force kombinasi dua variabel</li> </ul> Cetak Segitiga Bintang<pre><code>int n = 5;\nfor (int i = 1; i &lt;= n; i++) {\n    for (int j = 1; j &lt;= i; j++) {\n        cout &lt;&lt; \"*\";\n    }\n    cout &lt;&lt; endl;\n}\n// Output:\n// *\n// **\n// ***\n// ****\n// *****\n</code></pre> <ul> <li>Jumlah total iterasi = jumlah iterasi loop luar \u00d7 jumlah iterasi loop dalam.</li> <li>Hati-hati dengan kompleksitas waktu, terutama jika nilai n dan m besar.</li> <li>Nested loop bisa lebih dari dua tingkat, tetapi semakin dalam biasanya semakin berat secara komputasi.</li> </ul> <p>Nested loop sangat sering digunakan dalam pemrograman kompetitif, terutama untuk masalah pola, matriks, dan kombinasi.</p>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/01-perulangan/#kesimpulan","title":"Kesimpulan","text":"<p>Perulangan adalah konsep fundamental dalam pemrograman yang memungkinkan kita mengeksekusi blok kode secara berulang tanpa menulis kode yang sama berulang kali. Tiga jenis utama perulangan di C++ adalah <code>for</code>, <code>while</code>, dan <code>do-while</code>, masing-masing memiliki kegunaan dan karakteristik tersendiri: <code>for loop</code> cocok untuk jumlah iterasi yang pasti, <code>while loop</code> untuk kondisi dinamis, dan <code>do-while loop</code> untuk memastikan eksekusi minimal satu kali.</p> <p>Selain itu, perintah <code>break</code> dan <code>continue</code> sangat berguna untuk mengontrol alur eksekusi di dalam loop, seperti menghentikan loop lebih awal atau melewati iterasi tertentu. Konsep nested loop juga penting untuk menyelesaikan masalah yang meli batkan data dua dimensi atau kombinasi variabel.</p> <p>Anda akan sering menemukan penggunaan perulangan, break, continue, dan nested loop di berbagai soal pemrograman. Silakan mencoba soal-soal di bawah ini untuk memperdalam pemahaman Anda :3</p>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/01-perulangan/#contoh-soal-tlx","title":"Contoh soal TLX","text":"<ul> <li>Perkenalan Continue dan Break</li> <li>Mencari Pola 1</li> <li>Mencari Pola 2</li> <li>Mencari Pola 3</li> </ul>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/02-larik/","title":"Larik (Array)","text":"<p>Larik atau array merupakan struktur data fundamental yang sangat penting dalam pemrograman dan akan muncul di berbagai soal kompetitif, mulai dari penyimpanan data, pencarian, pengurutan, hingga algoritma dinamis. Dengan memahami array, kita dapat menyimpan dan mengolah banyak data dengan efisien tanpa membuat variabel berulang-ulang.</p>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/02-larik/#pengenalan","title":"Pengenalan","text":"<p>Mari kita mulai dengan contoh permasalahan sederhana:</p> <p>Simpan dan cetak nilai dari 5 siswa.</p> <p>Jika kita menulis: <pre><code>int nilai1, nilai2, nilai3, nilai4, nilai5;\ncin &gt;&gt; nilai1 &gt;&gt; nilai2 &gt;&gt; nilai3 &gt;&gt; nilai4 &gt;&gt; nilai5;\ncout &lt;&lt; nilai1 &lt;&lt; \" \" &lt;&lt; nilai2 &lt;&lt; \" \" &lt;&lt; nilai3 &lt;&lt; \" \" &lt;&lt; nilai4 &lt;&lt; \" \" &lt;&lt; nilai5;\n</code></pre> Maka jelas, ini tidak efisien. Di sinilah array dibutuhkan: kita bisa menyimpan banyak data dalam satu variabel dengan indeks yang berbeda.</p>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/02-larik/#deklarasi-array","title":"Deklarasi Array","text":"<p>Array adalah kumpulan elemen dengan tipe data yang sama, disimpan dalam lokasi memori yang berurutan.</p> Struktur Umum<pre><code>tipe_data nama_array[ukuran];\n</code></pre> Contoh Deklarasi<pre><code>int nilai[5];           // Array integer dengan 5 elemen\nchar huruf[10];         // Array karakter dengan 10 elemen\ndouble harga[100];      // Array double dengan 100 elemen\n</code></pre> <p>Kegunaan umum di pemrograman kompetitif:</p> <ul> <li>Menyimpan input data dalam jumlah besar</li> <li>Implementasi algoritma pencarian dan pengurutan</li> <li>Dynamic Programming</li> <li>Manipulasi string (array of char)</li> </ul>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/02-larik/#indeks-array","title":"Indeks Array","text":"<p>Array menggunakan sistem indeks yang dimulai dari 0. Untuk array dengan ukuran n, indeksnya adalah 0, 1, 2, ..., n-1.</p> Indeks nilai[0] nilai[1] nilai[2] nilai[3] nilai[4] Nilai 10 20 30 40 50 Mengakses Elemen Array<pre><code>int nilai[5];\nnilai[0] = 10;  // Elemen pertama\nnilai[1] = 20;  // Elemen kedua\nnilai[2] = 30;  // Elemen ketiga\nnilai[3] = 40;  // Elemen keempat\nnilai[4] = 50;  // Elemen kelima\n\ncout &lt;&lt; nilai[0] &lt;&lt; endl;  // Output: 10\ncout &lt;&lt; nilai[2] &lt;&lt; endl;  // Output: 30\n</code></pre> <p>Index Out of Bounds</p> <p>Pastikan indeks yang diakses tidak melebihi ukuran array. Mengakses <code>nilai[5]</code> pada array dengan ukuran 5 akan menyebabkan error atau perilaku tidak terduga.</p>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/02-larik/#inisialisasi-array","title":"Inisialisasi Array","text":"<p>Ada beberapa cara untuk menginisialisasi array:</p> Inisialisasi Langsung<pre><code>int angka[5] = {1, 2, 3, 4, 5};\n// angka[0] = 1, angka[1] = 2, dst.\n</code></pre> Inisialisasi Sebagian<pre><code>int angka[5] = {1, 2};  // Sisa elemen otomatis 0\n// angka[0] = 1, angka[1] = 2, angka[2] = 0, angka[3] = 0, angka[4] = 0\n</code></pre> Inisialisasi Semua Nol<pre><code>int angka[5] = {0};  // Semua elemen = 0\n// atau\nint angka[5] = {};   // Semua elemen = 0\n</code></pre> Auto-sizing<pre><code>int angka[] = {1, 2, 3, 4, 5};  // Ukuran otomatis = 5\n</code></pre>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/02-larik/#input-dan-output-array","title":"Input dan Output Array","text":"<p>Penggunaan perulangan sangat penting untuk mengisi dan menampilkan array:</p> Input Array<pre><code>int n = 5;\nint nilai[5];\n\n// Mengisi array\nfor (int i = 0; i &lt; n; i++) {\n    cin &gt;&gt; nilai[i];\n}\n</code></pre> Output Array<pre><code>// Menampilkan array\nfor (int i = 0; i &lt; n; i++) {\n    cout &lt;&lt; nilai[i] &lt;&lt; \" \";\n}\ncout &lt;&lt; endl;\n</code></pre> Contoh Lengkap<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int n;\n    cout &lt;&lt; \"Masukkan jumlah elemen: \";\n    cin &gt;&gt; n;\n\n    int arr[100];  // Maksimal 100 elemen\n\n    cout &lt;&lt; \"Masukkan \" &lt;&lt; n &lt;&lt; \" angka: \";\n    for (int i = 0; i &lt; n; i++) {\n        cin &gt;&gt; arr[i];\n    }\n\n    cout &lt;&lt; \"Array yang dimasukkan: \";\n    for (int i = 0; i &lt; n; i++) {\n        cout &lt;&lt; arr[i] &lt;&lt; \" \";\n    }\n    cout &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/02-larik/#operasi-dasar-array","title":"Operasi Dasar Array","text":""},{"location":"Pemrograman%20C%2B%2B%20Dasar/02-larik/#mencari-elemen","title":"Mencari Elemen","text":"Linear Search<pre><code>int cari = 30;\nbool found = false;\nint posisi = -1;\n\nfor (int i = 0; i &lt; n; i++) {\n    if (arr[i] == cari) {\n        found = true;\n        posisi = i;\n        break;\n    }\n}\n\nif (found) {\n    cout &lt;&lt; \"Elemen \" &lt;&lt; cari &lt;&lt; \" ditemukan di indeks \" &lt;&lt; posisi &lt;&lt; endl;\n} else {\n    cout &lt;&lt; \"Elemen tidak ditemukan\" &lt;&lt; endl;\n}\n</code></pre>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/02-larik/#mencari-nilai-maksimum-dan-minimum","title":"Mencari Nilai Maksimum dan Minimum","text":"Mencari Max dan Min<pre><code>int maksimum = arr[0];\nint minimum = arr[0];\n\nfor (int i = 1; i &lt; n; i++) {\n    if (arr[i] &gt; maksimum) {\n        maksimum = arr[i];\n    }\n    if (arr[i] &lt; minimum) {\n        minimum = arr[i];\n    }\n}\n\ncout &lt;&lt; \"Nilai maksimum: \" &lt;&lt; maksimum &lt;&lt; endl;\ncout &lt;&lt; \"Nilai minimum: \" &lt;&lt; minimum &lt;&lt; endl;\n</code></pre>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/02-larik/#menghitung-jumlah-dan-rata-rata","title":"Menghitung Jumlah dan Rata-rata","text":"Sum dan Average<pre><code>int jumlah = 0;\nfor (int i = 0; i &lt; n; i++) {\n    jumlah += arr[i];\n}\n\ndouble rata_rata = (double)jumlah / n;\ncout &lt;&lt; \"Jumlah: \" &lt;&lt; jumlah &lt;&lt; endl;\ncout &lt;&lt; \"Rata-rata: \" &lt;&lt; rata_rata &lt;&lt; endl;\n</code></pre>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/02-larik/#array-2-dimensi-matriks","title":"Array 2 Dimensi (Matriks)","text":"<p>Array 2 dimensi berguna untuk menyimpan data dalam bentuk tabel atau matriks:</p> Deklarasi Array 2D<pre><code>int matriks[3][4];  // 3 baris, 4 kolom\n// atau dengan inisialisasi\nint matriks[3][4] = {\n    {1, 2, 3, 4},\n    {5, 6, 7, 8},\n    {9, 10, 11, 12}\n};\n</code></pre> Input dan Output Array 2D<pre><code>int baris = 3, kolom = 4;\nint matriks[3][4];\n\n// Input\ncout &lt;&lt; \"Masukkan elemen matriks 3x4:\" &lt;&lt; endl;\nfor (int i = 0; i &lt; baris; i++) {\n    for (int j = 0; j &lt; kolom; j++) {\n        cin &gt;&gt; matriks[i][j];\n    }\n}\n\n// Output\ncout &lt;&lt; \"Matriks:\" &lt;&lt; endl;\nfor (int i = 0; i &lt; baris; i++) {\n    for (int j = 0; j &lt; kolom; j++) {\n        cout &lt;&lt; matriks[i][j] &lt;&lt; \" \";\n    }\n    cout &lt;&lt; endl;\n}\n</code></pre>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/02-larik/#visualisasi-array-2d","title":"Visualisasi Array 2D","text":"0 1 2 3 0 matriks[0][0]1 matriks[0][1]2 matriks[0][2]3 matriks[0][3]4 1 matriks[1][0]5 matriks[1][1]6 matriks[1][2]7 matriks[1][3]8 2 matriks[2][0]9 matriks[2][1]10 matriks[2][2]11 matriks[2][3]12"},{"location":"Pemrograman%20C%2B%2B%20Dasar/02-larik/#string-sebagai-array-karakter","title":"String sebagai Array Karakter","text":"<p>String dalam C++ dapat direpresentasikan sebagai array karakter:</p> Array Karakter<pre><code>char nama[50];\ncout &lt;&lt; \"Masukkan nama: \";\ncin &gt;&gt; nama;  // atau getline(cin, nama) untuk string dengan spasi\ncout &lt;&lt; \"Halo, \" &lt;&lt; nama &lt;&lt; endl;\n\n// Mengakses karakter individual\ncout &lt;&lt; \"Huruf pertama: \" &lt;&lt; nama[0] &lt;&lt; endl;\n</code></pre> Manipulasi String<pre><code>char kata[20] = \"Hello\";\nint panjang = 0;\n\n// Menghitung panjang string\nwhile (kata[panjang] != '\\0') {\n    panjang++;\n}\ncout &lt;&lt; \"Panjang kata: \" &lt;&lt; panjang &lt;&lt; endl;\n</code></pre>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/02-larik/#tips-dan-catatan-penting","title":"Tips dan Catatan Penting","text":"<p>Bounds Checking</p> <p>C++ tidak melakukan pengecekan batas array secara otomatis. Pastikan selalu menggunakan indeks yang valid: <pre><code>int arr[5];\narr[10] = 100;  // Berbahaya! Dapat menyebabkan crash\n</code></pre></p> <p>Inisialisasi Awal</p> <p>Selalu inisialisasi array sebelum digunakan untuk menghindari nilai sampah: <pre><code>int arr[100] = {0};  // Semua elemen diisi 0\n</code></pre></p>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/02-larik/#kesimpulan","title":"Kesimpulan","text":"<p>Array adalah struktur data fundamental yang memungkinkan kita menyimpan dan mengolah banyak data dengan tipe yang sama secara efisien. Konsep indeks yang dimulai dari 0, operasi input/output menggunakan perulangan, dan berbagai algoritma dasar seperti pencarian dan pengurutan adalah skill penting yang harus dikuasai.</p> <p>Array 2 dimensi berguna untuk representasi data tabular dan matriks, sementara array karakter dapat digunakan untuk manipulasi string dasar. Memahami array dengan baik akan menjadi fondasi untuk mempelajari struktur data yang lebih kompleks seperti vector, stack, queue, dan algoritma yang lebih advanced.</p> <p>Praktik yang konsisten dengan berbagai operasi array akan membantu Anda menguasai konsep ini dengan baik. Array sangat sering muncul dalam soal pemrograman kompetitif, jadi pastikan Anda memahami semua konsep dasar yang telah dijelaskan.</p>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/02-larik/#contoh-soal-tlx","title":"Contoh Soal TLX","text":"<ul> <li>Kandang Terbesar</li> <li>Jual Beli Bebek III</li> <li>Bermain Lampu Kandang</li> <li>Toko Kandang II</li> <li>Menutup Toko</li> </ul>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/03-fungsi/","title":"Fungsi","text":"<p>Fungsi merupakan blok kode yang dapat dipanggil berulang kali untuk melakukan tugas tertentu, mulai dari modularisasi kode, implementasi algoritma, hingga penggunaan library functions. Dengan memahami fungsi, kita dapat menulis kode yang lebih terorganisir, mudah dibaca, dan dapat digunakan kembali.</p>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/03-fungsi/#pengenalan","title":"Pengenalan","text":"<p>Mari kita mulai dengan contoh permasalahan sederhana:</p> <p>Hitung luas persegi panjang untuk beberapa pasang panjang dan lebar yang berbeda.</p> <p>Jika kita menulis: <pre><code>int panjang1 = 5, lebar1 = 3;\nint luas1 = panjang1 * lebar1;\ncout &lt;&lt; \"Luas 1: \" &lt;&lt; luas1 &lt;&lt; endl;\n\nint panjang2 = 7, lebar2 = 4;\nint luas2 = panjang2 * lebar2;\ncout &lt;&lt; \"Luas 2: \" &lt;&lt; luas2 &lt;&lt; endl;\n// ... dan seterusnya\n</code></pre> Maka jelas, ini tidak efisien. Di sinilah fungsi dibutuhkan: kita bisa membuat satu blok kode yang dapat dipanggil berulang kali dengan parameter yang berbeda.</p>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/03-fungsi/#deklarasi-dan-definisi-fungsi","title":"Deklarasi dan Definisi Fungsi","text":"<p>Fungsi adalah blok kode yang menerima input (parameter), melakukan pemrosesan, dan dapat mengembalikan output (return value).</p> Struktur Umum<pre><code>tipe_return nama_fungsi(parameter1, parameter2, ...) {\n    // blok kode\n    return nilai; // opsional\n}\n</code></pre> Contoh Fungsi Sederhana<pre><code>// Fungsi menghitung luas persegi panjang\nint hitungLuas(int panjang, int lebar) {\n    int luas = panjang * lebar;\n    return luas;\n}\n\n// Fungsi tanpa return value (void)\nvoid cetakPesan(string pesan) {\n    cout &lt;&lt; \"Pesan: \" &lt;&lt; pesan &lt;&lt; endl;\n}\n</code></pre> <p>Kegunaan umum di pemrograman kompetitif:</p> <ul> <li>Modularisasi kode untuk menghindari repetisi</li> <li>Implementasi algoritma khusus (sorting, searching)</li> <li>Validasi input dan output</li> <li>Penggunaan library functions untuk efisiensi</li> </ul>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/03-fungsi/#memanggil-fungsi","title":"Memanggil Fungsi","text":"<p>Setelah fungsi didefinisikan, kita dapat memanggilnya di dalam program:</p> Pemanggilan Fungsi<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\n// Definisi fungsi\nint hitungLuas(int panjang, int lebar) {\n    return panjang * lebar;\n}\n\nvoid cetakPesan(string pesan) {\n    cout &lt;&lt; \"Pesan: \" &lt;&lt; pesan &lt;&lt; endl;\n}\n\nint main() {\n    // Memanggil fungsi dengan return value\n    int hasil = hitungLuas(5, 3);\n    cout &lt;&lt; \"Luas: \" &lt;&lt; hasil &lt;&lt; endl;\n\n    // Memanggil fungsi void\n    cetakPesan(\"Hello World!\");\n\n    // Memanggil langsung dalam cout\n    cout &lt;&lt; \"Luas 2: \" &lt;&lt; hitungLuas(7, 4) &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/03-fungsi/#return","title":"Return","text":"<p>Keyword <code>return</code> digunakan di dalam fungsi untuk mengembalikan nilai ke pemanggil fungsi. Saat <code>return</code> dijalankan, eksekusi fungsi akan berhenti dan nilai setelah <code>return</code> akan dikirimkan kembali ke tempat fungsi tersebut dipanggil.</p> <p>Contoh pada fungsi hitungLuas<pre><code>int hitungLuas(int panjang, int lebar) {\n    return panjang * lebar;\n}\n</code></pre> Pada contoh di atas, <code>return panjang * lebar;</code> akan mengembalikan hasil perkalian <code>panjang</code> dan <code>lebar</code> ke pemanggil fungsi. Nilai ini bisa disimpan dalam variabel atau langsung digunakan, seperti pada contoh:</p> Pemanggilan hitungluas()<pre><code>int hasil = hitungLuas(5, 3); // hasil akan bernilai 15\n</code></pre>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/03-fungsi/#tipe-tipe-fungsi","title":"Tipe-tipe Fungsi","text":"<p>Secara umum, fungsi di C++ dapat dikategorikan berdasarkan ada tidaknya parameter dan return value:</p> Tipe Fungsi Parameter Return Value Contoh Deklarasi Fungsi tanpa parameter, tanpa return Tidak Tidak <code>void tampilkanMenu();</code> Fungsi tanpa parameter, dengan return Tidak Ya <code>int getNilai();</code> Fungsi dengan parameter, tanpa return Ya Tidak <code>void cetakPesan(string pesan);</code> Fungsi dengan parameter, dengan return Ya Ya <code>int tambah(int a, int b);</code>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/03-fungsi/#contoh-implementasi","title":"Contoh Implementasi","text":"Tipe-tipe Fungsi<pre><code>// Tanpa parameter, tanpa return\nvoid tampilkanMenu() {\n    cout &lt;&lt; \"1. Tambah\\n2. Kurang\\n3. Keluar\\n\";\n}\n\n// Tanpa parameter, dengan return\nint getNilai() {\n    int x;\n    cout &lt;&lt; \"Masukkan nilai: \";\n    cin &gt;&gt; x;\n    return x;\n}\n\n// Dengan parameter, tanpa return\nvoid cetakPesan(string pesan) {\n    cout &lt;&lt; \"Pesan: \" &lt;&lt; pesan &lt;&lt; endl;\n}\n\n// Dengan parameter, dengan return\nint tambah(int a, int b) {\n    return a + b;\n}\n</code></pre> <p>Penggunaan tipe fungsi yang tepat akan membuat kode lebih jelas dan sesuai kebutuhan.</p>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/03-fungsi/#parameter-dan-argumen","title":"Parameter dan Argumen","text":""},{"location":"Pemrograman%20C%2B%2B%20Dasar/03-fungsi/#pass-by-value","title":"Pass by Value","text":"<p>Secara default, C++ menggunakan pass by value, artinya nilai parameter disalin ke dalam fungsi:</p> Pass by Value<pre><code>void tambahSatu(int x) {\n    x = x + 1;\n    cout &lt;&lt; \"Dalam fungsi: \" &lt;&lt; x &lt;&lt; endl; // Output: 6\n}\n\nint main() {\n    int angka = 5;\n    tambahSatu(angka);\n    cout &lt;&lt; \"Di main: \" &lt;&lt; angka &lt;&lt; endl; // Output: 5 (tidak berubah)\n    return 0;\n}\n</code></pre>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/03-fungsi/#pass-by-reference","title":"Pass by Reference","text":"<p>Menggunakan <code>&amp;</code> untuk mengubah nilai variabel asli:</p> Pass by Reference<pre><code>void tambahSatu(int &amp;x) {\n    x = x + 1;\n    cout &lt;&lt; \"Dalam fungsi: \" &lt;&lt; x &lt;&lt; endl; // Output: 6\n}\n\nint main() {\n    int angka = 5;\n    tambahSatu(angka);\n    cout &lt;&lt; \"Di main: \" &lt;&lt; angka &lt;&lt; endl; // Output: 6 (berubah)\n    return 0;\n}\n</code></pre>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/03-fungsi/#pass-array-ke-fungsi","title":"Pass Array ke Fungsi","text":"<p>Array selalu di-pass by reference secara otomatis:</p> Array sebagai Parameter<pre><code>void cetakArray(int arr[], int ukuran) {\n    for (int i = 0; i &lt; ukuran; i++) {\n        cout &lt;&lt; arr[i] &lt;&lt; \" \";\n    }\n    cout &lt;&lt; endl;\n}\n\nvoid isiArray(int arr[], int ukuran, int nilai) {\n    for (int i = 0; i &lt; ukuran; i++) {\n        arr[i] = nilai;\n    }\n}\n\nint main() {\n    int data[5] = {1, 2, 3, 4, 5};\n\n    cetakArray(data, 5);    // Output: 1 2 3 4 5\n    isiArray(data, 5, 0);   // Mengubah semua elemen jadi 0\n    cetakArray(data, 5);    // Output: 0 0 0 0 0\n\n    return 0;\n}\n</code></pre>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/03-fungsi/#algoritma-dan-utility-functions","title":"Algoritma dan Utility Functions","text":""},{"location":"Pemrograman%20C%2B%2B%20Dasar/03-fungsi/#contoh-implementasi-algoritma","title":"Contoh Implementasi Algoritma","text":"Binary Search Function<pre><code>bool binarySearch(int arr[], int n, int target) {\n    int left = 0, right = n - 1;\n\n    while (left &lt;= right) {\n        int mid = left + (right - left) / 2;\n\n        if (arr[mid] == target) {\n            return true;\n        }\n\n        if (arr[mid] &lt; target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    return false;\n}\n</code></pre> Bubble Sort Function<pre><code>void bubbleSort(int arr[], int n) {\n    for (int i = 0; i &lt; n - 1; i++) {\n        for (int j = 0; j &lt; n - i - 1; j++) {\n            if (arr[j] &gt; arr[j + 1]) {\n                // Swap elements\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/03-fungsi/#utility-functions","title":"Utility Functions","text":"Utility Functions<pre><code>// Fungsi untuk menukar dua nilai\nvoid swap(int&amp; a, int&amp; b) {\n    int temp = a;\n    a = b;\n    b = temp;\n}\n\n// Fungsi untuk cek bilangan prima\nbool isPrime(int n) {\n    if (n &lt;= 1) return false;\n    if (n &lt;= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    for (int i = 5; i * i &lt;= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Fungsi untuk menghitung faktorial\nlong long factorial(int n) {\n    if (n &lt;= 1) return 1;\n\n    long long result = 1;\n    for (int i = 2; i &lt;= n; i++) {\n        result *= i;\n    }\n    return result;\n}\n</code></pre>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/03-fungsi/#library-functions-yang-populer","title":"Library Functions yang Populer","text":""},{"location":"Pemrograman%20C%2B%2B%20Dasar/03-fungsi/#algorithm-library-algorithm","title":"Algorithm Library (<code>&lt;algorithm&gt;</code>)","text":"<p>Library ini menyediakan banyak fungsi algoritma yang sangat berguna:</p> Sort Function<pre><code>#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nint main() {\n    // Sort array\n    int arr[] = {5, 2, 8, 1, 9, 3};\n    int n = 6;\n    sort(arr, arr + n);  // Sort ascending\n\n    // Sort vector\n    vector&lt;int&gt; vec = {5, 2, 8, 1, 9, 3};\n    sort(vec.begin(), vec.end());  // Sort ascending\n    sort(vec.begin(), vec.end(), greater&lt;int&gt;());  // Sort descending\n\n    return 0;\n}\n</code></pre> Max dan Min Functions<pre><code>#include &lt;algorithm&gt;\n\nint main() {\n    // Max dan Min untuk dua nilai\n    int a = 5, b = 3;\n    cout &lt;&lt; \"Max: \" &lt;&lt; max(a, b) &lt;&lt; endl;    // Output: 5\n    cout &lt;&lt; \"Min: \" &lt;&lt; min(a, b) &lt;&lt; endl;    // Output: 3\n\n    // Max dan Min dalam array\n    int arr[] = {5, 2, 8, 1, 9, 3};\n    int n = 6;\n\n    int maximum = *max_element(arr, arr + n);  // 9\n    int minimum = *min_element(arr, arr + n);  // 1\n\n    cout &lt;&lt; \"Maximum: \" &lt;&lt; maximum &lt;&lt; endl;\n    cout &lt;&lt; \"Minimum: \" &lt;&lt; minimum &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre> Binary Search Functions<pre><code>#include &lt;algorithm&gt;\n\nint main() {\n    int arr[] = {1, 2, 3, 5, 8, 9};  // Harus sudah sorted\n    int n = 6;\n\n    // Binary search (return true/false)\n    bool found = binary_search(arr, arr + n, 5);\n    cout &lt;&lt; \"5 found: \" &lt;&lt; found &lt;&lt; endl;  // Output: 1 (true)\n\n    // Lower bound (iterator ke elemen &gt;= target)\n    int* pos = lower_bound(arr, arr + n, 5);\n    cout &lt;&lt; \"Lower bound of 5: \" &lt;&lt; pos - arr &lt;&lt; endl;  // Index\n\n    // Upper bound (iterator ke elemen &gt; target)\n    pos = upper_bound(arr, arr + n, 5);\n    cout &lt;&lt; \"Upper bound of 5: \" &lt;&lt; pos - arr &lt;&lt; endl;  // Index\n\n    return 0;\n}\n</code></pre>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/03-fungsi/#numeric-library-numeric","title":"Numeric Library (<code>&lt;numeric&gt;</code>)","text":"GCD dan LCM<pre><code>#include &lt;numeric&gt;  // C++17 ke atas\n\nint main() {\n    int a = 12, b = 18;\n\n    // GCD (Greatest Common Divisor)\n    int gcd_result = __gcd(a, b);  // GCC specific\n    // atau dalam C++17:\n    // int gcd_result = gcd(a, b);\n\n    // LCM (Least Common Multiple)\n    int lcm_result = (a * b) / gcd_result;\n    // atau dalam C++17:\n    // int lcm_result = lcm(a, b);\n\n    cout &lt;&lt; \"GCD: \" &lt;&lt; gcd_result &lt;&lt; endl;  // Output: 6\n    cout &lt;&lt; \"LCM: \" &lt;&lt; lcm_result &lt;&lt; endl;  // Output: 36\n\n    return 0;\n}\n</code></pre>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/03-fungsi/#math-library-cmath","title":"Math Library (<code>&lt;cmath&gt;</code>)","text":"Math Functions<pre><code>#include &lt;cmath&gt;\n\nint main() {\n    double x = 16.0;\n\n    cout &lt;&lt; \"sqrt(16): \" &lt;&lt; sqrt(x) &lt;&lt; endl;     // 4\n    cout &lt;&lt; \"pow(2, 3): \" &lt;&lt; pow(2, 3) &lt;&lt; endl;  // 8\n    cout &lt;&lt; \"abs(-5): \" &lt;&lt; abs(-5) &lt;&lt; endl;      // 5\n    cout &lt;&lt; \"ceil(4.3): \" &lt;&lt; ceil(4.3) &lt;&lt; endl;  // 5\n    cout &lt;&lt; \"floor(4.7): \" &lt;&lt; floor(4.7) &lt;&lt; endl; // 4\n\n    return 0;\n}\n</code></pre>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/03-fungsi/#contoh-penggunaan-dalam-competitive-programming","title":"Contoh Penggunaan dalam Competitive Programming","text":"Complete Example<pre><code>#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\n// Custom function untuk cek palindrome\nbool isPalindrome(string s) {\n    int n = s.length();\n    for (int i = 0; i &lt; n / 2; i++) {\n        if (s[i] != s[n - 1 - i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Function untuk mencari median\ndouble findMedian(vector&lt;int&gt;&amp; arr) {\n    sort(arr.begin(), arr.end());\n    int n = arr.size();\n\n    if (n % 2 == 1) {\n        return arr[n / 2];\n    } else {\n        return (arr[n / 2 - 1] + arr[n / 2]) / 2.0;\n    }\n}\n\nint main() {\n    // Contoh penggunaan sort\n    vector&lt;int&gt; numbers = {5, 2, 8, 1, 9, 3};\n    sort(numbers.begin(), numbers.end());\n\n    cout &lt;&lt; \"Sorted: \";\n    for (int x : numbers) {\n        cout &lt;&lt; x &lt;&lt; \" \";\n    }\n    cout &lt;&lt; endl;\n\n    // Contoh penggunaan max/min\n    cout &lt;&lt; \"Max: \" &lt;&lt; *max_element(numbers.begin(), numbers.end()) &lt;&lt; endl;\n    cout &lt;&lt; \"Min: \" &lt;&lt; *min_element(numbers.begin(), numbers.end()) &lt;&lt; endl;\n\n    // Contoh penggunaan GCD\n    cout &lt;&lt; \"GCD(12, 18): \" &lt;&lt; __gcd(12, 18) &lt;&lt; endl;\n\n    // Contoh penggunaan custom function\n    string word = \"radar\";\n    cout &lt;&lt; word &lt;&lt; \" is palindrome: \" &lt;&lt; isPalindrome(word) &lt;&lt; endl;\n\n    // Contoh median\n    vector&lt;int&gt; data = {1, 3, 2, 5, 4};\n    cout &lt;&lt; \"Median: \" &lt;&lt; findMedian(data) &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/03-fungsi/#tips-dan-best-practices","title":"Tips dan Best Practices","text":"<p>Function Naming</p> <p>Gunakan nama fungsi yang deskriptif dan mengikuti konvensi: <pre><code>// Good\nbool isPrime(int n);\nint calculateSum(int arr[], int size);\n\n// Bad\nbool check(int n);\nint calc(int arr[], int size);\n</code></pre></p> <p>Parameter Validation</p> <p>Selalu validasi parameter untuk menghindari error: <pre><code>int factorial(int n) {\n    if (n &lt; 0) return -1;  // Invalid input\n    if (n &lt;= 1) return 1;\n\n    // ... rest of the code\n}\n</code></pre></p> <p>Stack Overflow</p> <p>Hati-hati dengan fungsi yang terlalu dalam atau parameter array yang besar: <pre><code>// Hindari passing array besar by value\nvoid processArray(int arr[1000000]) {  // Berbahaya!\n    // ...\n}\n\n// Lebih baik pass by reference\nvoid processArray(int arr[], int size) {\n    // ...\n}\n</code></pre></p>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/03-fungsi/#scope-dan-lifetime-variabel","title":"Scope dan Lifetime Variabel","text":"Variable Scope<pre><code>int globalVar = 100;  // Global variable\n\nvoid function1() {\n    int localVar = 10;  // Local variable\n    cout &lt;&lt; globalVar &lt;&lt; endl;  // Bisa akses global\n    cout &lt;&lt; localVar &lt;&lt; endl;   // Bisa akses local\n}\n\nvoid function2() {\n    cout &lt;&lt; globalVar &lt;&lt; endl;  // Bisa akses global\n    // cout &lt;&lt; localVar &lt;&lt; endl; // ERROR! localVar tidak bisa diakses\n}\n\nint main() {\n    function1();\n    function2();\n    return 0;\n}\n</code></pre>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/03-fungsi/#kesimpulan","title":"Kesimpulan","text":"<p>Fungsi adalah konsep fundamental yang memungkinkan kita menulis kode yang modular, dapat digunakan kembali, dan mudah dipelihara. Dengan memahami parameter passing (by value vs by reference), function overloading, dan penggunaan library functions yang populer seperti <code>sort()</code>, <code>max()</code>, <code>min()</code>, <code>__gcd()</code>, kita dapat menulis solusi yang lebih efisien dan elegant.</p> <p>Library functions seperti yang ada di <code>&lt;algorithm&gt;</code>, <code>&lt;numeric&gt;</code>, dan <code>&lt;cmath&gt;</code> sangat membantu dalam competitive programming karena sudah dioptimasi dan terbukti benar. Namun, penting juga untuk bisa mengimplementasi algoritma sendiri untuk memahami cara kerjanya.</p>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/03-fungsi/#contoh-soal-tlx","title":"Contoh Soal TLX","text":"<ul> <li>Memborong Bebek</li> <li>Perkenalan Fungsi</li> <li>Ruang Lingkup Variabel dan Fungsi</li> <li>0 dan &gt; 1 Parameter</li> <li>Fungsi Tanpa Nilai Kembalian</li> <li>Fungsi Anggota</li> <li>Pass by Reference</li> </ul>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/04-string/","title":"String","text":"<p>String merupakan struktur data fundamental yang sangat penting dalam pemrograman dan akan selalu muncul di berbagai soal kompetitif, mulai dari manipulasi teks, parsing input, pattern matching, hingga algoritma string. Dengan memahami string dan method-methodnya, kita dapat mengolah data teks dengan efisien dan menyelesaikan berbagai permasalahan yang melibatkan karakter dan kata.</p>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/04-string/#pengenalan","title":"Pengenalan","text":"<p>Mari kita mulai dengan contoh permasalahan sederhana:</p> <p>Simpan nama lengkap seseorang dan tampilkan informasi tentangnya.</p> <p>Jika kita menulis: <pre><code>char huruf1 = 'J';\nchar huruf2 = 'o';\nchar huruf3 = 'h';\nchar huruf4 = 'n';\n// ... dan seterusnya\n</code></pre> Maka jelas, ini tidak efisien. Di sinilah string dibutuhkan: kita bisa menyimpan rangkaian karakter dalam satu variabel dan memanipulasinya dengan mudah.</p>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/04-string/#deklarasi-string","title":"Deklarasi String","text":"<p>String dalam C++ dapat direpresentasikan dalam dua cara utama: sebagai array karakter (C-style) atau sebagai objek string (C++ style).</p> Deklarasi String<pre><code>// C-style string (array karakter)\nchar nama[50];\n\n// C++ style string (objek string)\nstring nama;\n</code></pre> Contoh Deklarasi dan Inisialisasi<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nint main() {\n    // Berbagai cara deklarasi string\n    string greeting = \"Hello\";          // Inisialisasi langsung\n    string name(\"World\");               // Constructor\n    string message;                     // String kosong\n    char cstr[] = \"Hello World\";        // C-style string\n\n    return 0;\n}\n</code></pre> <p>Kegunaan umum di pemrograman kompetitif:</p> <ul> <li>Parsing dan manipulasi input teks</li> <li>Pattern matching dan string searching</li> <li>Implementasi algoritma string (KMP, Z-algorithm)</li> <li>Validasi format data</li> </ul>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/04-string/#input-dan-output-string","title":"Input dan Output String","text":""},{"location":"Pemrograman%20C%2B%2B%20Dasar/04-string/#input-string","title":"Input String","text":"Input String Sederhana<pre><code>string kata;\ncin &gt;&gt; kata;  // Membaca satu kata (sampai spasi)\ncout &lt;&lt; \"Kata: \" &lt;&lt; kata &lt;&lt; endl;\n</code></pre> Input String dengan Spasi<pre><code>string kalimat;\ngetline(cin, kalimat);  // Membaca satu baris lengkap\ncout &lt;&lt; \"Kalimat: \" &lt;&lt; kalimat &lt;&lt; endl;\n</code></pre>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/04-string/#output-string","title":"Output String","text":"Output String<pre><code>string message = \"Hello World\";\ncout &lt;&lt; message &lt;&lt; endl;\ncout &lt;&lt; \"Panjang: \" &lt;&lt; message.length() &lt;&lt; endl;\n</code></pre>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/04-string/#method-method-string-yang-penting","title":"Method-Method String yang Penting","text":""},{"location":"Pemrograman%20C%2B%2B%20Dasar/04-string/#length-dan-size","title":"Length dan Size","text":"Mengukur Panjang String<pre><code>string text = \"Programming\";\ncout &lt;&lt; \"Length: \" &lt;&lt; text.length() &lt;&lt; endl;  // Output: 11\ncout &lt;&lt; \"Size: \" &lt;&lt; text.size() &lt;&lt; endl;      // Output: 11 (sama dengan length)\ncout &lt;&lt; \"Empty: \" &lt;&lt; text.empty() &lt;&lt; endl;    // Output: 0 (false)\n\nstring kosong = \"\";\ncout &lt;&lt; \"Empty: \" &lt;&lt; kosong.empty() &lt;&lt; endl;  // Output: 1 (true)\n</code></pre>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/04-string/#akses-karakter","title":"Akses Karakter","text":"Mengakses Karakter Individual<pre><code>string word = \"Hello\";\n\n// Menggunakan operator []\ncout &lt;&lt; \"Karakter pertama: \" &lt;&lt; word[0] &lt;&lt; endl;    // H\ncout &lt;&lt; \"Karakter terakhir: \" &lt;&lt; word[4] &lt;&lt; endl;   // o\n\n// Menggunakan method at()\ncout &lt;&lt; \"Karakter kedua: \" &lt;&lt; word.at(1) &lt;&lt; endl;   // e\n\n// Method front() dan back()\ncout &lt;&lt; \"Depan: \" &lt;&lt; word.front() &lt;&lt; endl;          // H\ncout &lt;&lt; \"Belakang: \" &lt;&lt; word.back() &lt;&lt; endl;        // o\n</code></pre>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/04-string/#concatenation-penggabungan","title":"Concatenation (Penggabungan)","text":"Menggabungkan String<pre><code>string first = \"Hello\";\nstring second = \"World\";\n\n// Menggunakan operator +\nstring result1 = first + \" \" + second;\ncout &lt;&lt; result1 &lt;&lt; endl;  // Hello World\n\n// Menggunakan operator +=\nfirst += \" \";\nfirst += second;\ncout &lt;&lt; first &lt;&lt; endl;    // Hello World\n\n// Menggunakan append()\nstring greeting = \"Hi\";\ngreeting.append(\" there\");\ncout &lt;&lt; greeting &lt;&lt; endl; // Hi there\n</code></pre>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/04-string/#substring","title":"Substring","text":"Mengambil Bagian String<pre><code>string text = \"Programming\";\n\n// substr(start_pos, length)\nstring sub1 = text.substr(0, 4);    // \"Prog\"\nstring sub2 = text.substr(4);       // \"ramming\" (dari indeks 4 sampai akhir)\nstring sub3 = text.substr(4, 3);    // \"ram\"\n\ncout &lt;&lt; sub1 &lt;&lt; endl;\ncout &lt;&lt; sub2 &lt;&lt; endl;\ncout &lt;&lt; sub3 &lt;&lt; endl;\n</code></pre>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/04-string/#find-dan-search","title":"Find dan Search","text":"Mencari dalam String<pre><code>string sentence = \"I love programming and programming loves me\";\n\n// Mencari substring\nint pos = sentence.find(\"programming\"); // Output: 7, pencarian akan dilakukan dari index 0 hingga menemukan kalimat yang diinginkan\n\n// Anda juga bisa mencari programming yang muncul kedua dengan memberikan argumen index dimana pencarian akan dimulai\npos = sentence.find(\"programming\", 8) // Pencarian akan dilakukan dari index 8 pada sentence\n</code></pre>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/04-string/#replace","title":"Replace","text":"Mengganti Bagian String<pre><code>string text = \"I like apples and apples are good\";\n\n// replace(start_pos, length, new_string)\ntext.replace(7, 6, \"oranges\");  // Ganti \"apples\" dengan \"oranges\"\ncout &lt;&lt; text &lt;&lt; endl;  // I like oranges and apples are good\n\n// Mengganti semua kemunculan\nstring original = \"cat cat cat\";\nstring target = \"cat\";\nstring replacement = \"dog\";\n\nsize_t pos = 0;\nwhile ((pos = original.find(target, pos)) != string::npos) {\n    original.replace(pos, target.length(), replacement);\n    pos += replacement.length();\n}\ncout &lt;&lt; original &lt;&lt; endl;  // dog dog dog\n</code></pre>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/04-string/#insert-dan-erase","title":"Insert dan Erase","text":"Menyisipkan dan Menghapus<pre><code>string text = \"Hello World\";\n\n// Insert - menyisipkan string\ntext.insert(5, \" Beautiful\");\ncout &lt;&lt; text &lt;&lt; endl;  // Hello Beautiful World\n\n// Erase - menghapus bagian string\ntext.erase(5, 10);     // Hapus \" Beautiful\"\ncout &lt;&lt; text &lt;&lt; endl;  // Hello World\n\n// Erase dari posisi tertentu sampai akhir\nstring sample = \"Programming\";\nsample.erase(4);       // Hapus dari indeks 4 sampai akhir\ncout &lt;&lt; sample &lt;&lt; endl; // Prog\n</code></pre>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/04-string/#compare","title":"Compare","text":"Membandingkan String<pre><code>string str1 = \"Apple\";\nstring str2 = \"Banana\";\nstring str3 = \"Apple\";\n\n// Menggunakan operator ==, !=, &lt;, &gt;, &lt;=, &gt;=\ncout &lt;&lt; (str1 == str3) &lt;&lt; endl;  // 1 (true)\ncout &lt;&lt; (str1 &lt; str2) &lt;&lt; endl;   // 1 (true, karena A &lt; B)\n\n// Menggunakan method compare()\nint result = str1.compare(str2);\nif (result &lt; 0) {\n    cout &lt;&lt; str1 &lt;&lt; \" &lt; \" &lt;&lt; str2 &lt;&lt; endl;\n} else if (result &gt; 0) {\n    cout &lt;&lt; str1 &lt;&lt; \" &gt; \" &lt;&lt; str2 &lt;&lt; endl;\n} else {\n    cout &lt;&lt; str1 &lt;&lt; \" == \" &lt;&lt; str2 &lt;&lt; endl;\n}\n</code></pre>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/04-string/#konversi-string","title":"Konversi String","text":""},{"location":"Pemrograman%20C%2B%2B%20Dasar/04-string/#string-ke-angka","title":"String ke Angka","text":"String to Number<pre><code>#include &lt;string&gt;\n\nstring num_str = \"123\";\nstring float_str = \"45.67\";\n\n// C++11 methods\nint num = stoi(num_str);           // string to int\nlong long_num = stol(num_str);     // string to long\nfloat f = stof(float_str);         // string to float\ndouble d = stod(float_str);        // string to double\n\ncout &lt;&lt; \"Integer: \" &lt;&lt; num &lt;&lt; endl;\ncout &lt;&lt; \"Double: \" &lt;&lt; d &lt;&lt; endl;\n</code></pre>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/04-string/#angka-ke-string","title":"Angka ke String","text":"Number to String<pre><code>int number = 42;\ndouble pi = 3.14159;\n\n// C++11 method\nstring str_num = to_string(number);\nstring str_pi = to_string(pi);\n\ncout &lt;&lt; \"String number: \" &lt;&lt; str_num &lt;&lt; endl;\ncout &lt;&lt; \"String pi: \" &lt;&lt; str_pi &lt;&lt; endl;\n</code></pre>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/04-string/#iterasi-string","title":"Iterasi String","text":"<p>String dapat diiterasi seperti array:</p> Iterasi String<pre><code>string word = \"Hello\";\n\n// Menggunakan index\nfor (int i = 0; i &lt; word.length(); i++) {\n    cout &lt;&lt; word[i] &lt;&lt; \" \";\n}\ncout &lt;&lt; endl;\n\n// Menggunakan range-based for loop (C++11)\nfor (char c : word) {\n    cout &lt;&lt; c &lt;&lt; \" \";\n}\ncout &lt;&lt; endl;\n\n// Menggunakan iterator\nfor (auto it = word.begin(); it != word.end(); it++) {\n    cout &lt;&lt; *it &lt;&lt; \" \";\n}\ncout &lt;&lt; endl;\n</code></pre>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/04-string/#contoh-aplikasi-praktis","title":"Contoh Aplikasi Praktis","text":""},{"location":"Pemrograman%20C%2B%2B%20Dasar/04-string/#validasi-input","title":"Validasi Input","text":"Validasi Email Sederhana<pre><code>bool isValidEmail(string email) {\n    size_t at_pos = email.find('@');\n    size_t dot_pos = email.rfind('.');\n\n    return (at_pos != string::npos &amp;&amp; \n            dot_pos != string::npos &amp;&amp; \n            at_pos &lt; dot_pos &amp;&amp;\n            at_pos &gt; 0 &amp;&amp;\n            dot_pos &lt; email.length() - 1);\n}\n\nint main() {\n    string email;\n    cout &lt;&lt; \"Masukkan email: \";\n    cin &gt;&gt; email;\n\n    if (isValidEmail(email)) {\n        cout &lt;&lt; \"Email valid\" &lt;&lt; endl;\n    } else {\n        cout &lt;&lt; \"Email tidak valid\" &lt;&lt; endl;\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/04-string/#word-count","title":"Word Count","text":"Menghitung Kata<pre><code>int countWords(string sentence) {\n    if (sentence.empty()) return 0;\n\n    int count = 0;\n    bool inWord = false;\n\n    for (char c : sentence) {\n        if (c != ' ' &amp;&amp; !inWord) {\n            inWord = true;\n            count++;\n        } else if (c == ' ') {\n            inWord = false;\n        }\n    }\n\n    return count;\n}\n\nint main() {\n    string text = \"Hello world programming\";\n    cout &lt;&lt; \"Jumlah kata: \" &lt;&lt; countWords(text) &lt;&lt; endl;  // Output: 3\n    return 0;\n}\n</code></pre>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/04-string/#palindrome-check","title":"Palindrome Check","text":"Cek Palindrome<pre><code>bool isPalindrome(string str) {\n    // Convert to lowercase dan hapus spasi\n    string clean = \"\";\n    for (char c : str) {\n        if (c != ' ') {\n            clean += tolower(c);\n        }\n    }\n\n    int left = 0;\n    int right = clean.length() - 1;\n\n    while (left &lt; right) {\n        if (clean[left] != clean[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n\n    return true;\n}\n\nint main() {\n    string word = \"A man a plan a canal Panama\";\n    cout &lt;&lt; word &lt;&lt; \" is palindrome: \" &lt;&lt; isPalindrome(word) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/04-string/#string-tokenization","title":"String Tokenization","text":"Memisahkan String<pre><code>vector&lt;string&gt; split(string str, char delimiter) {\n    vector&lt;string&gt; tokens;\n    string token = \"\";\n\n    for (char c : str) {\n        if (c == delimiter) {\n            if (!token.empty()) {\n                tokens.push_back(token);\n                token = \"\";\n            }\n        } else {\n            token += c;\n        }\n    }\n\n    if (!token.empty()) {\n        tokens.push_back(token);\n    }\n\n    return tokens;\n}\n\nint main() {\n    string data = \"apple,banana,orange,grape\";\n    vector&lt;string&gt; fruits = split(data, ',');\n\n    for (string fruit : fruits) {\n        cout &lt;&lt; fruit &lt;&lt; endl;\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/04-string/#tips-dan-best-practices","title":"Tips dan Best Practices","text":"<p>String Efficiency</p> <p>Untuk operasi string yang banyak, pertimbangkan menggunakan <code>reserve()</code> untuk menghindari realokasi: <pre><code>string result;\nresult.reserve(1000);  // Reserve space untuk 1000 karakter\n\nfor (int i = 0; i &lt; 100; i++) {\n    result += \"test\";\n}\n</code></pre></p> <p>String Comparison</p> <p>Perbandingan string bersifat lexicographical (berdasarkan ASCII): <pre><code>string a = \"Apple\";\nstring b = \"Banana\";\ncout &lt;&lt; (a &lt; b) &lt;&lt; endl;  // true, karena 'A' &lt; 'B'\n\n// Untuk case-insensitive comparison:\ntransform(a.begin(), a.end(), a.begin(), ::tolower);\ntransform(b.begin(), b.end(), b.begin(), ::tolower);\n</code></pre></p> <p>Index Out of Bounds</p> <p>Selalu periksa bounds saat mengakses karakter: <pre><code>string text = \"Hello\";\nif (index &lt; text.length()) {\n    char c = text[index];  // Safe access\n}\n\n// Atau gunakan at() yang throw exception\ntry {\n    char c = text.at(index);\n} catch (out_of_range&amp; e) {\n    cout &lt;&lt; \"Index out of bounds!\" &lt;&lt; endl;\n}\n</code></pre></p>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/04-string/#algorithm-library-untuk-string","title":"Algorithm Library untuk String","text":"Useful String Algorithms<pre><code>#include &lt;algorithm&gt;\n#include &lt;string&gt;\n\nint main() {\n    string text = \"Programming\";\n\n    // Reverse string\n    reverse(text.begin(), text.end());\n    cout &lt;&lt; text &lt;&lt; endl;  // gnimmargorP\n\n    // Sort karakter dalam string\n    string word = \"hello\";\n    sort(word.begin(), word.end());\n    cout &lt;&lt; word &lt;&lt; endl;  // ehllo\n\n    // Remove duplicates\n    string dup = \"programming\";\n    sort(dup.begin(), dup.end());\n    dup.erase(unique(dup.begin(), dup.end()), dup.end());\n    cout &lt;&lt; dup &lt;&lt; endl;  // agimnopr\n\n    // Transform to uppercase\n    string lower = \"hello world\";\n    transform(lower.begin(), lower.end(), lower.begin(), ::toupper);\n    cout &lt;&lt; lower &lt;&lt; endl;  // HELLO WORLD\n\n    return 0;\n}\n</code></pre>"},{"location":"Pemrograman%20C%2B%2B%20Dasar/04-string/#kesimpulan","title":"Kesimpulan","text":"<p>String adalah struktur data fundamental yang memungkinkan kita menyimpan dan memanipulasi data teks dengan efisien. Dengan memahami berbagai method seperti <code>find()</code>, <code>substr()</code>, <code>replace()</code>, <code>insert()</code>, dan <code>erase()</code>, kita dapat menyelesaikan berbagai permasalahan yang melibatkan pemrosesan teks.</p>"},{"location":"Topik%20Umum/Graf%20Dasar/01-menyimpan-graf/","title":"Menyimpan Graf","text":"<p>Graf merupakan struktur data yang sangat umum dalam pemrograman kompetitif lanjut, mulai dari algoritma traversal, shortest path, cycle detection, tree dan varian lainnya. Sebelum mempelajari algoritma penjelajahan dan komputasi pada graf, kita perlu memahami cara menyimpan graf dalam C++. Berbeda dengan visualisasi manusia, komputer memerlukan representasi khusus untuk graf agar operasi seperti menambah/menghapus edge, mengiterasi tetangga, dan akses data dapat dilakukan secara optimal.</p>"},{"location":"Topik%20Umum/Graf%20Dasar/01-menyimpan-graf/#pengenalan-graf","title":"Pengenalan Graf","text":"<p>Graf adalah struktur data yang terdiri dari kumpulan simpul (vertex/node) dan sisi (edge) yang menghubungkan simpul-simpul tersebut. Graf dapat berupa:</p> <ul> <li>Directed Graph (Digraph): Sisi memiliki arah</li> <li>Undirected Graph: Sisi tidak memiliki arah  </li> <li>Weighted Graph: Setiap sisi memiliki bobot</li> <li>Unweighted Graph: Semua sisi memiliki bobot sama</li> </ul> <pre><code>graph LR\n    A --- B\n    A --- C\n    B --- D\n    C --- D\n    D --- E</code></pre> <p>Contoh graf sederhana dengan 5 simpul dan 5 sisi.</p>"},{"location":"Topik%20Umum/Graf%20Dasar/01-menyimpan-graf/#representasi-graf","title":"Representasi Graf","text":"<p>Ada tiga cara utama untuk merepresentasikan graf dalam program:</p> <ol> <li>Adjacency Matrix - Menggunakan matriks 2D</li> <li>Adjacency List - Menggunakan array/vector dari list</li> <li>Edge List - Menyimpan semua sisi dalam satu list</li> </ol> <p>Mari kita bahas masing-masing representasi beserta kelebihan dan kekurangannya.</p>"},{"location":"Topik%20Umum/Graf%20Dasar/01-menyimpan-graf/#adjacency-matrix","title":"Adjacency Matrix","text":"<p>Adjacency matrix menggunakan matriks 2D untuk merepresentasikan graf, di mana <code>matrix[i][j]</code> menunjukkan apakah ada sisi dari simpul <code>i</code> ke simpul <code>j</code>.</p>"},{"location":"Topik%20Umum/Graf%20Dasar/01-menyimpan-graf/#implementasi-adjacency-matrix","title":"Implementasi Adjacency Matrix","text":"Unweighted Undirected Graph<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    int n = 5; // jumlah vertex (0-4)\n\n    // Membuat adjacency matrix\n    vector&lt;vector&lt;int&gt;&gt; adj(n, vector&lt;int&gt;(n, 0));\n\n    // Menambah sisi untuk undirected graph\n    // Sisi: (0,1), (0,2), (1,3), (2,3), (3,4)\n    adj[0][1] = adj[1][0] = 1;\n    adj[0][2] = adj[2][0] = 1;\n    adj[1][3] = adj[3][1] = 1;\n    adj[2][3] = adj[3][2] = 1;\n    adj[3][4] = adj[4][3] = 1;\n\n    // Cetak adjacency matrix\n    cout &lt;&lt; \"Adjacency Matrix:\" &lt;&lt; endl;\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = 0; j &lt; n; j++) {\n            cout &lt;&lt; adj[i][j] &lt;&lt; \" \";\n        }\n        cout &lt;&lt; endl;\n    }\n\n    // Cek apakah ada sisi antara vertex 0 dan 1\n    if (adj[0][1] == 1) {\n        cout &lt;&lt; \"Ada sisi antara vertex 0 dan 1\" &lt;&lt; endl;\n    }\n\n    return 0;\n}\n</code></pre> Weighted Directed Graph<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    int n = 4; // jumlah vertex\n    const int INF = 1e9; // nilai untuk \"tidak ada sisi\"\n\n    // Membuat weighted adjacency matrix\n    vector&lt;vector&lt;int&gt;&gt; adj(n, vector&lt;int&gt;(n, INF));\n\n    // Diagonal elements = 0 (jarak ke diri sendiri)\n    for (int i = 0; i &lt; n; i++) {\n        adj[i][i] = 0;\n    }\n\n    // Menambah sisi dengan bobot untuk directed graph\n    // Format: adj[from][to] = weight\n    adj[0][1] = 10;\n    adj[0][2] = 5;\n    adj[1][3] = 7;\n    adj[2][3] = 3;\n\n    // Cetak weighted matrix\n    cout &lt;&lt; \"Weighted Adjacency Matrix:\" &lt;&lt; endl;\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = 0; j &lt; n; j++) {\n            if (adj[i][j] == INF) {\n                cout &lt;&lt; \"\u221e \";\n            } else {\n                cout &lt;&lt; adj[i][j] &lt;&lt; \" \";\n            }\n        }\n        cout &lt;&lt; endl;\n    }\n\n    return 0;\n}\n</code></pre> <p>Output Adjacency Matrix: <pre><code>Adjacency Matrix:\n0 1 1 0 0\n1 0 0 1 0\n1 0 0 1 0\n0 1 1 0 1\n0 0 0 1 0\n\nWeighted Adjacency Matrix:\n0 10 5 \u221e\n\u221e 0 \u221e 7\n\u221e \u221e 0 3\n\u221e \u221e \u221e 0\n</code></pre></p>"},{"location":"Topik%20Umum/Graf%20Dasar/01-menyimpan-graf/#kompleksitas-adjacency-matrix","title":"Kompleksitas Adjacency Matrix","text":"Operasi Kompleksitas Space O(V\u00b2) Add Edge O(1) Check Edge O(1) Get All Neighbors O(V) Remove Edge O(1)"},{"location":"Topik%20Umum/Graf%20Dasar/01-menyimpan-graf/#kelebihan-dan-kekurangan-matrix","title":"Kelebihan dan Kekurangan Matrix","text":"<p>Kelebihan: - Cek keberadaan sisi sangat cepat O(1) - Implementasi sederhana dan intuitif - Cocok untuk algoritma yang membutuhkan akses acak ke semua pasangan vertex - Ideal untuk graf padat (dense graph)</p> <p>Kekurangan: - Memory usage besar O(V\u00b2), tidak efisien untuk graf jarang - Tidak bisa menyimpan multiple edges antara dua vertex - Untuk graf besar (V &gt; 10\u2074), bisa menyebabkan Memory Limit Exceeded</p>"},{"location":"Topik%20Umum/Graf%20Dasar/01-menyimpan-graf/#adjacency-list","title":"Adjacency List","text":"<p>Adjacency list menggunakan array/vector dari list untuk menyimpan graf, di mana setiap indeks menyimpan list dari semua simpul yang terhubung dengannya.</p>"},{"location":"Topik%20Umum/Graf%20Dasar/01-menyimpan-graf/#implementasi-adjacency-list","title":"Implementasi Adjacency List","text":"Unweighted Graph<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    int n = 5; // jumlah vertex (0-4)\n\n    // Membuat adjacency list\n    vector&lt;int&gt; adj[n];\n\n    // Menambah sisi untuk undirected graph\n    // Sisi: (0,1), (0,2), (1,3), (2,3), (3,4)\n    adj[0].push_back(1); adj[1].push_back(0);\n    adj[0].push_back(2); adj[2].push_back(0);\n    adj[1].push_back(3); adj[3].push_back(1);\n    adj[2].push_back(3); adj[3].push_back(2);\n    adj[3].push_back(4); adj[4].push_back(3);\n\n    // Cetak adjacency list\n    cout &lt;&lt; \"Adjacency List:\" &lt;&lt; endl;\n    for (int i = 0; i &lt; n; i++) {\n        cout &lt;&lt; \"Vertex \" &lt;&lt; i &lt;&lt; \": \";\n        for (int neighbor : adj[i]) {\n            cout &lt;&lt; neighbor &lt;&lt; \" \";\n        }\n        cout &lt;&lt; endl;\n    }\n\n    // Cetak semua tetangga dari vertex 0\n    cout &lt;&lt; \"\\nTetangga dari vertex 0: \";\n    for (int neighbor : adj[0]) {\n        cout &lt;&lt; neighbor &lt;&lt; \" \";\n    }\n    cout &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre> <p>For Each Loop</p> <p><code>for (int neighbor : adj[i])</code> adalah contoh dari for each loop yang memungkinkan anda melakukan iterasi pada elemen dari suatu array atau vector.</p> Weighted Graph<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    int n = 4; // jumlah vertex\n\n    // Adjacency list dengan pair&lt;vertex, weight&gt;\n    vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; adj(n);\n\n    // Menambah sisi dengan bobot (directed graph)\n    // Format: adj[from].push_back({to, weight})\n    adj[0].push_back({1, 10});\n    adj[0].push_back({2, 5});\n    adj[1].push_back({3, 7});\n    adj[2].push_back({3, 3});\n\n    // Cetak weighted adjacency list\n    cout &lt;&lt; \"Weighted Adjacency List:\" &lt;&lt; endl;\n    for (int i = 0; i &lt; n; i++) {\n        cout &lt;&lt; \"Vertex \" &lt;&lt; i &lt;&lt; \": \";\n        for (auto edge : adj[i]) {\n            cout &lt;&lt; \"(\" &lt;&lt; edge.first &lt;&lt; \",\" &lt;&lt; edge.second &lt;&lt; \") \";\n        }\n        cout &lt;&lt; endl;\n    }\n\n    return 0;\n}\n</code></pre> <p>Pair</p> <p><code>pair&lt;int, int&gt;</code> adalah struktur data C++ yang dapat menyimpan dua nilai dengan tipe yang bisa berbeda. Dalam konteks weighted graph, kita menggunakan <code>pair&lt;int, int&gt;</code> untuk menyimpan pasangan <code>{vertex, weight}</code>. Akses nilai pertama dengan <code>.first</code> dan nilai kedua dengan <code>.second</code>. Contoh: <code>{3, 7}</code> berarti edge menuju vertex 3 dengan bobot</p> <p>Output Adjacency List: <pre><code>Adjacency List:\nVertex 0: 1 2\nVertex 1: 0 3\nVertex 2: 0 3\nVertex 3: 1 2 4\nVertex 4: 3\n\nWeighted Adjacency List:\nVertex 0: (1,10) (2,5)\nVertex 1: (3,7)\nVertex 2: (3,3)\nVertex 3:\n</code></pre></p>"},{"location":"Topik%20Umum/Graf%20Dasar/01-menyimpan-graf/#kompleksitas-adjacency-list","title":"Kompleksitas Adjacency List","text":"Operasi Kompleksitas Space O(V + E) Add Edge O(1) Check Edge O(degree(v)) Get All Neighbors O(degree(v)) Remove Edge O(degree(v))"},{"location":"Topik%20Umum/Graf%20Dasar/01-menyimpan-graf/#kelebihan-dan-kekurangan-list","title":"Kelebihan dan Kekurangan List","text":"<p>Kelebihan: - Memory efficient untuk sparse graph - Iterasi tetangga sangat cepat - Paling umum digunakan dalam competitive programming - Bisa menyimpan multiple edges dan self-loops - Cocok untuk sebagian besar algoritma graf</p> <p>Kekurangan: - Cek keberadaan sisi lebih lambat daripada matrix - Implementasi sedikit lebih kompleks - Remove edge tidak efisien</p>"},{"location":"Topik%20Umum/Graf%20Dasar/01-menyimpan-graf/#edge-list","title":"Edge List","text":"<p>Edge list menyimpan semua sisi graf dalam satu struktur data, biasanya vector. Setiap sisi direpresentasikan sebagai struct atau tuple yang berisi informasi simpul-simpul yang terhubung.</p>"},{"location":"Topik%20Umum/Graf%20Dasar/01-menyimpan-graf/#implementasi-edge-list","title":"Implementasi Edge List","text":"Unweighted Graph<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct Edge {\n    int u, v;\n};\n\nint main() {\n    int n = 5; // jumlah vertex\n    vector&lt;Edge&gt; edges;\n\n    // Menambah sisi (undirected graph disimpan sekali saja)\n    edges.push_back({0, 1});\n    edges.push_back({0, 2});\n    edges.push_back({1, 3});\n    edges.push_back({2, 3});\n    edges.push_back({3, 4});\n\n    // Cetak semua sisi\n    cout &lt;&lt; \"Edge List:\" &lt;&lt; endl;\n    for (Edge e : edges) {\n        cout &lt;&lt; e.u &lt;&lt; \" -- \" &lt;&lt; e.v &lt;&lt; endl;\n    }\n\n    // Cari semua sisi yang terhubung ke vertex 0\n    cout &lt;&lt; \"\\nSisi yang terhubung ke vertex 0:\" &lt;&lt; endl;\n    for (Edge e : edges) {\n        if (e.u == 0 || e.v == 0) {\n            cout &lt;&lt; e.u &lt;&lt; \" -- \" &lt;&lt; e.v &lt;&lt; endl;\n        }\n    }\n\n    return 0;\n}\n</code></pre> <p>Output Edge List: <pre><code>Edge List:\n0 -- 1\n0 -- 2\n1 -- 3\n2 -- 3\n3 -- 4\n</code></pre></p>"},{"location":"Topik%20Umum/Graf%20Dasar/01-menyimpan-graf/#kompleksitas-edge-list","title":"Kompleksitas Edge List","text":"Operasi Kompleksitas Space O(E) Add Edge O(1) Check Edge O(E) Get All Neighbors O(E) Remove Edge O(E)"},{"location":"Topik%20Umum/Graf%20Dasar/01-menyimpan-graf/#kelebihan-dan-kekurangan-edge-list","title":"Kelebihan dan Kekurangan Edge List","text":"<p>Kelebihan: - Memory paling efisien O(E) - Mudah untuk sort berdasarkan weight - Simple untuk beberapa algoritma khusus (Kruskal's MST) - Cocok untuk input/output dalam format edge list</p> <p>Kekurangan: - Akses tetangga sangat lambat O(E) - Cek keberadaan sisi sangat lambat O(E) - Kurang fleksibel untuk kebanyakan algoritma graf - Tidak efisien untuk operasi yang membutuhkan akses berulang ke tetangga</p>"},{"location":"Topik%20Umum/Graf%20Dasar/01-menyimpan-graf/#perbandingan-representasi-graf","title":"Perbandingan Representasi Graf","text":"Aspek Adjacency Matrix Adjacency List Edge List Space Complexity O(V\u00b2) O(V + E) O(E) Add Edge O(1) O(1) O(1) Check Edge O(1) O(degree) O(E) Get Neighbors O(V) O(degree) O(E) Remove Edge O(1) O(degree) O(E) <p>Keterangan: - V = jumlah vertex - E = jumlah edge - degree = jumlah tetangga suatu vertex</p>"},{"location":"Topik%20Umum/Graf%20Dasar/01-menyimpan-graf/#kapan-menggunakan-masing-masing-representasi","title":"Kapan Menggunakan Masing-masing Representasi?","text":""},{"location":"Topik%20Umum/Graf%20Dasar/01-menyimpan-graf/#adjacency-matrix_1","title":"Adjacency Matrix","text":"<p>Gunakan ketika: - Graf padat (dense graph) dengan banyak sisi - Sering perlu cek apakah ada sisi antara dua vertex - Algoritma Floyd-Warshall untuk all-pairs shortest path - Graf kecil (V \u2264 1000) - Butuh akses random ke semua pasangan vertex</p> Template Matrix untuk CP<pre><code>int adj[1000][1000];\nbool visited[1000][1000]; // untuk grid/maze\nint dist[1000][1000];     // untuk shortest path\n</code></pre>"},{"location":"Topik%20Umum/Graf%20Dasar/01-menyimpan-graf/#adjacency-list_1","title":"Adjacency List","text":"<p>Gunakan ketika: - Graf jarang (sparse graph) - ini yang paling umum - Algoritma traversal (BFS, DFS) - Algoritma shortest path (Dijkstra, Bellman-Ford) - Sebagian besar soal competitive programming - Graf besar dengan sedikit sisi per vertex</p> Template List untuk CP<pre><code>vector&lt;int&gt; adj[n + 1];              // unweighted\nvector&lt;pair&lt;int, int&gt;&gt; adj[n + 1];   // weighted: pair&lt;vertex, weight&gt;\n</code></pre>"},{"location":"Topik%20Umum/Graf%20Dasar/01-menyimpan-graf/#edge-list_1","title":"Edge List","text":"<p>Gunakan ketika: - Algoritma Kruskal untuk Minimum Spanning Tree - Union-Find operations - Perlu sort berdasarkan weight - Input/output dalam format edge list - Hanya butuh iterasi semua edges tanpa akses tetangga</p> Template Edge List untuk CP<pre><code>vector&lt;tuple&lt;int, int, int&gt;&gt; edges;  // {weight, u, v}\n</code></pre>"},{"location":"Topik%20Umum/Graf%20Dasar/01-menyimpan-graf/#tips-untuk-competitive-programming","title":"Tips untuk Competitive Programming","text":"<p>Pilihan Default</p> <p>Gunakan Adjacency List sebagai pilihan default. Ini cocok untuk sebagian besar soal graf.</p> <p>Memory Consideration</p> <p>Untuk V &gt; 10\u2074, hindari adjacency matrix karena bisa menyebabkan MLE: <pre><code>// JANGAN: matrix 100000x100000 = 40GB memory!\nint matrix[100000][100000]; \n\n// GUNAKAN: adjacency list\nvector&lt;vector&lt;int&gt;&gt; adj(n + 1);\n</code></pre></p> <p>1-indexed vs 0-indexed</p> <p>Banyak soal CP menggunakan vertex 1-indexed: <pre><code>vector&lt;vector&lt;int&gt;&gt; adj(n + 1); // 0..n, gunakan 1..n\n</code></pre> Jadi hati hati ya :3</p>"},{"location":"Topik%20Umum/Graf%20Dasar/01-menyimpan-graf/#kesimpulan","title":"Kesimpulan","text":"<p>Memilih representasi graf yang tepat sangat penting untuk efisiensi program:</p> <ul> <li>Adjacency List \u2192 Pilihan default untuk kebanyakan soal CP</li> <li>Adjacency Matrix \u2192 Graf kecil padat atau algoritma khusus</li> <li>Edge List \u2192 Algoritma yang butuh sorting edges (MST)</li> </ul> <p>Memahami trade-off masing-masing representasi akan membantu Anda menulis solusi yang efisien dan menghindari TLE atau MLE. Adjacency list dengan vector adalah yang paling fleksibel dan memory-efficient untuk sebagian besar kasus.</p>"},{"location":"Topik%20Umum/Graf%20Dasar/02-penjelajahan-graf/","title":"Penjelajahan Graf","text":"<p>Penjelajahan graf adalah teknik dasar yang wajib dikuasai dalam pemrograman kompetitif. Algoritma seperti BFS dan DFS sering digunakan untuk berbagai tujuan, seperti mencari jalur, mendeteksi siklus, memeriksa keterhubungan, dan menemukan shortest path.</p>"},{"location":"Topik%20Umum/Graf%20Dasar/02-penjelajahan-graf/#pengenalan-penjelajahan-graf","title":"Pengenalan Penjelajahan Graf","text":"<p>Penjelajahan graf adalah proses mengunjungi semua vertex dalam graf secara sistematis. Ada dua algoritma utama untuk penjelajahan graf:</p> <ol> <li>Breadth-First Search (BFS) - Penjelajahan melebar</li> <li>Depth-First Search (DFS) - Penjelajahan mendalam</li> </ol> <p>Kedua algoritma ini memiliki karakteristik dan kegunaan yang berbeda, sehingga penting untuk memahami kapan menggunakan masing-masing algoritma.</p>"},{"location":"Topik%20Umum/Graf%20Dasar/02-penjelajahan-graf/#konsep-dasar","title":"Konsep Dasar","text":"<p>Sebelum membahas algoritma penjelajahan, kita perlu memahami konsep visited array - sebuah array boolean yang menandai vertex mana saja yang sudah dikunjungi untuk menghindari infinite loop.</p> Setup Dasar<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;queue&gt;\n#include &lt;cstring&gt; // untuk memset\nusing namespace std;\n\n// Graf yang akan digunakan dalam contoh\nvector&lt;int&gt; adj[6]; // adjacency list untuk 6 vertex (0-5)\nbool visited[6];    // array untuk menandai vertex yang sudah dikunjungi\n\nvoid resetVisited() {\n    for (int i = 0; i &lt; 6; i++) {\n        visited[i] = false;\n    }\n    // Alternatif menggunakan memset:\n    // memset(visited, false, sizeof(visited));\n}\n</code></pre> <p>Mari kita gunakan graf contoh berikut untuk menjelaskan kedua algoritma:</p> <pre><code>graph LR\n    0 --- 1\n    0 --- 2\n    1 --- 3\n    2 --- 4\n    3 --- 5\n    4 --- 5</code></pre> <p>Graf dengan 6 vertex (0-5) dan 6 edges.</p>"},{"location":"Topik%20Umum/Graf%20Dasar/02-penjelajahan-graf/#depth-first-search-dfs","title":"Depth-First Search (DFS)","text":"<p>DFS adalah algoritma penjelajahan yang mengunjungi vertex secara mendalam - artinya kita mengikuti satu jalur sejauh mungkin sebelum backtrack dan mencoba jalur lain.</p>"},{"location":"Topik%20Umum/Graf%20Dasar/02-penjelajahan-graf/#karakteristik-dfs","title":"Karakteristik DFS:","text":"<ul> <li>Menggunakan stack (LIFO - Last In First Out) atau rekursi</li> <li>Mengunjungi vertex secara mendalam terlebih dahulu</li> <li>Cocok untuk deteksi cycle, topological sort</li> <li>Backtracking approach</li> </ul>"},{"location":"Topik%20Umum/Graf%20Dasar/02-penjelajahan-graf/#implementasi-dfs-rekursif","title":"Implementasi DFS (Rekursif)","text":"DFS Recursive Implementation<pre><code>void DFS_recursive(int vertex) {\n    visited[vertex] = true;\n    cout &lt;&lt; vertex &lt;&lt; \" \";\n\n    // Kunjungi semua tetangga yang belum dikunjungi\n    for (int neighbor : adj[vertex]) {\n        if (!visited[neighbor]) {\n            DFS_recursive(neighbor);\n        }\n    }\n}\n\nvoid DFS(int start) {\n    cout &lt;&lt; \"DFS traversal: \";\n    DFS_recursive(start);\n    cout &lt;&lt; endl;\n}\n</code></pre>"},{"location":"Topik%20Umum/Graf%20Dasar/02-penjelajahan-graf/#implementasi-dfs-iteratif","title":"Implementasi DFS (Iteratif)","text":"DFS Iterative Implementation<pre><code>void DFS_iterative(int start) {\n    stack&lt;int&gt; s;\n    vector&lt;bool&gt; vis(6, false);\n\n    s.push(start);\n    cout &lt;&lt; \"DFS traversal: \";\n\n    while (!s.empty()) {\n        int current = s.top();\n        s.pop();\n\n        if (!vis[current]) {\n            vis[current] = true;\n            cout &lt;&lt; current &lt;&lt; \" \";\n\n            // Push tetangga ke stack\n            for (int neighbor : adj[current]) {\n                if (!vis[neighbor]) {\n                    s.push(neighbor);\n                }\n            }\n        }\n    }\n    cout &lt;&lt; endl;\n}\n</code></pre>"},{"location":"Topik%20Umum/Graf%20Dasar/02-penjelajahan-graf/#langkah-langkah-dfs","title":"Langkah-langkah DFS:","text":"<p>Visualisasi langkah-langkah DFS dimulai dari vertex 0 </p> <p>Gambar diambil dari Buku Pemrograman Kompetitif Dasar TOKI</p> <ol> <li>Mulai dari starting vertex, tandai sebagai visited</li> <li>Rekursi/Stack: Untuk setiap tetangga yang belum dikunjungi:</li> <li>Tandai sebagai visited</li> <li>Lakukan DFS dari tetangga tersebut</li> <li>Backtrack: Ketika tidak ada tetangga yang belum dikunjungi, kembali ke vertex sebelumnya</li> </ol>"},{"location":"Topik%20Umum/Graf%20Dasar/02-penjelajahan-graf/#contoh-eksekusi-dfs","title":"Contoh Eksekusi DFS","text":"Contoh Program DFS<pre><code>int main() {\n    // Menggunakan graf yang sama\n    memset(vis, false, sizeof(vis));\n    DFS(0);\n\n    return 0;\n}\n</code></pre> <p>Output: <pre><code>DFS traversal: 0 1 3 5 4 2\n</code></pre></p>"},{"location":"Topik%20Umum/Graf%20Dasar/02-penjelajahan-graf/#kompleksitas-dfs","title":"Kompleksitas DFS","text":"Aspek Kompleksitas Time Complexity O(V + E) Space Complexity O(V)"},{"location":"Topik%20Umum/Graf%20Dasar/02-penjelajahan-graf/#breadth-first-search-bfs","title":"Breadth-First Search (BFS)","text":"<p>BFS adalah algoritma penjelajahan yang mengunjungi vertex secara melebar - artinya kita mengunjungi semua tetangga langsung dari vertex saat ini sebelum pindah ke level yang lebih dalam.</p>"},{"location":"Topik%20Umum/Graf%20Dasar/02-penjelajahan-graf/#karakteristik-bfs","title":"Karakteristik BFS:","text":"<ul> <li>Menggunakan queue (FIFO - First In First Out)</li> <li>Mengunjungi vertex berdasarkan jarak dari starting vertex</li> <li>Menjamin path terpendek dalam unweighted graph</li> <li>Level-by-level traversal</li> </ul>"},{"location":"Topik%20Umum/Graf%20Dasar/02-penjelajahan-graf/#implementasi-bfs","title":"Implementasi BFS","text":"BFS Implementation<pre><code>void BFS(int start) {\n    queue&lt;int&gt; q;\n\n    // Mulai dari vertex start\n    visited[start] = true;\n    q.push(start);\n\n    cout &lt;&lt; \"BFS traversal: \";\n\n    while (!q.empty()) {\n        int current = q.front();\n        q.pop();\n\n        cout &lt;&lt; current &lt;&lt; \" \";\n\n        // Kunjungi semua tetangga yang belum dikunjungi\n        for (int neighbor : adj[current]) {\n            if (!visited[neighbor]) {\n                visited[neighbor] = true;\n                q.push(neighbor);\n            }\n        }\n    }\n    cout &lt;&lt; endl;\n}\n</code></pre>"},{"location":"Topik%20Umum/Graf%20Dasar/02-penjelajahan-graf/#langkah-langkah-bfs","title":"Langkah-langkah BFS:","text":"<p>Visualisasi langkah-langkah BFS dimulai dari vertex 0 </p> <p>Gambar diambil dari Buku Pemrograman Kompetitif Dasar TOKI</p> <ol> <li>Inisialisasi: Masukkan starting vertex ke queue, tandai sebagai visited</li> <li>Loop: Selama queue tidak kosong:</li> <li>Ambil vertex dari depan queue</li> <li>Proses vertex tersebut</li> <li>Masukkan semua tetangga yang belum dikunjungi ke queue</li> <li>Tandai tetangga sebagai visited</li> </ol>"},{"location":"Topik%20Umum/Graf%20Dasar/02-penjelajahan-graf/#contoh-eksekusi-bfs","title":"Contoh Eksekusi BFS","text":"Contoh Program BFS<pre><code>int main() {\n    // Membangun graf contoh\n    adj[0].push_back(1); adj[1].push_back(0);\n    adj[0].push_back(2); adj[2].push_back(0);\n    adj[1].push_back(3); adj[3].push_back(1);\n    adj[2].push_back(4); adj[4].push_back(2);\n    adj[3].push_back(5); adj[5].push_back(3);\n    adj[4].push_back(5); adj[5].push_back(4);\n\n    memset(vis, false, sizeof(vis));\n    BFS(0);\n\n    return 0;\n}\n</code></pre> <p>Output: <pre><code>BFS traversal: 0 1 2 3 4 5\n</code></pre></p>"},{"location":"Topik%20Umum/Graf%20Dasar/02-penjelajahan-graf/#kompleksitas-bfs","title":"Kompleksitas BFS","text":"Aspek Kompleksitas Time Complexity O(V + E) Space Complexity O(V) <ul> <li>V = jumlah vertex</li> <li>E = jumlah edges</li> </ul>"},{"location":"Topik%20Umum/Graf%20Dasar/02-penjelajahan-graf/#kapan-menggunakan-bfs-vs-dfs","title":"Kapan Menggunakan BFS vs DFS?","text":""},{"location":"Topik%20Umum/Graf%20Dasar/02-penjelajahan-graf/#gunakan-bfs-ketika","title":"Gunakan BFS ketika:","text":"<ul> <li>Mencari shortest path dalam unweighted graph</li> <li>Level-order traversal diperlukan</li> <li>Breadth-wise exploration lebih penting</li> <li>Solving puzzle dengan minimum moves</li> <li>Tree/graph level analysis</li> </ul>"},{"location":"Topik%20Umum/Graf%20Dasar/02-penjelajahan-graf/#gunakan-dfs-ketika","title":"Gunakan DFS ketika:","text":"<ul> <li>Cycle detection dalam graf</li> <li>Topological sorting</li> <li>Exploring all possible paths</li> <li>Connected components analysis</li> <li>Backtracking problems</li> <li>Tree traversal (pre/post-order)</li> </ul>"},{"location":"Topik%20Umum/Graf%20Dasar/02-penjelajahan-graf/#perbandingan-bfs-vs-dfs","title":"Perbandingan BFS vs DFS","text":"Aspek BFS DFS Data Structure Queue (FIFO) Stack/Recursion (LIFO) Memory Usage O(V) O(V) Shortest Path \u2705 Unweighted \u274c Tidak menjamin Cycle Detection \u2705 Possible \u2705 Natural Connected Components \u2705 Good \u2705 Excellent Topological Sort \u274c Tidak cocok \u2705 Natural Maze Solving \u2705 Optimal path \u2705 Any path"},{"location":"Topik%20Umum/Graf%20Dasar/02-penjelajahan-graf/#contoh","title":"Contoh","text":"Template BFS &amp; DFS untuk CP<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;queue&gt;\n#include &lt;stack&gt;\nusing namespace std;\n\nconst int MAXN = 100005;\nvector&lt;int&gt; adj[MAXN];\nbool visited[MAXN];\n\n// BFS Template\nvoid bfs(int start) {\n    queue&lt;int&gt; q;\n    visited[start] = true;\n    q.push(start);\n\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n\n        // Process vertex u\n        cout &lt;&lt; u &lt;&lt; \" \";\n\n        for (int v : adj[u]) {\n            if (!visited[v]) {\n                visited[v] = true;\n                q.push(v);\n            }\n        }\n    }\n}\n\n// DFS Template\nvoid dfs(int u) {\n    visited[u] = true;\n\n    // Process vertex u\n    cout &lt;&lt; u &lt;&lt; \" \";\n\n    for (int v : adj[u]) {\n        if (!visited[v]) {\n            dfs(v);\n        }\n    }\n}\n\nint main() {\n    int n, m; // n = vertices, m = edges\n    cin &gt;&gt; n &gt;&gt; m;\n\n    for (int i = 0; i &lt; m; i++) {\n        int u, v;\n        cin &gt;&gt; u &gt;&gt; v;\n        adj[u].push_back(v);\n        adj[v].push_back(u); // untuk undirected graph\n    }\n\n    cout &lt;&lt; \"BFS: \";\n    memset(vis, false, sizeof(vis));\n    bfs(1);\n    cout &lt;&lt; endl;\n\n    cout &lt;&lt; \"DFS: \";\n    memset(vis, false, sizeof(vis));\n    dfs(1);\n    cout &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"Topik%20Umum/Graf%20Dasar/02-penjelajahan-graf/#tips-untuk-competitive-programming","title":"Tips untuk Competitive Programming","text":"<p>Visited Array</p> <p>Selalu reset visited array saat melakukan multiple traversal: <pre><code>memset(visited, false, sizeof(visited));\n</code></pre></p> <p>Infinite Loop</p> <p>Pastikan selalu menandai vertex sebagai visited sebelum memasukkannya ke queue/stack untuk menghindari duplicate processing.</p>"},{"location":"Topik%20Umum/Graf%20Dasar/03-variasi-umum/","title":"Variasi Umum BFS dan DFS","text":"<p>Setelah memahami algoritma dasar BFS dan DFS, penting untuk menguasai berbagai variasi yang sering digunakan dalam pemrograman kompetitif. Variasi-variasi ini sangat berguna untuk menyelesaikan masalah graf yang lebih kompleks seperti pengecekan konektivitas, deteksi siklus, pencarian jalur terpendek, dan rekonstruksi jalur.</p>"},{"location":"Topik%20Umum/Graf%20Dasar/03-variasi-umum/#pengenalan-variasi","title":"Pengenalan Variasi","text":"<p>Algoritma BFS dan DFS memiliki banyak aplikasi praktis yang merupakan modifikasi dari implementasi dasar. Variasi-variasi ini memungkinkan kita untuk:</p> <ul> <li>Menganalisis struktur graf (connected components, cycles)</li> <li>Mencari jalur optimal (shortest path, path finding)</li> <li>Melakukan operasi dari multiple sources secara bersamaan</li> <li>Merekonstruksi jalur yang telah ditemukan</li> </ul> <p>Mari kita bahas setiap variasi dengan implementasi dan contoh penggunaannya.</p>"},{"location":"Topik%20Umum/Graf%20Dasar/03-variasi-umum/#connected-components","title":"Connected Components","text":""},{"location":"Topik%20Umum/Graf%20Dasar/03-variasi-umum/#masalah","title":"Masalah","text":"<p>Connected component adalah kelompok vertex dalam graf di mana setiap vertex dapat dijangkau dari vertex lain dalam kelompok yang sama. Menentukan jumlah dan isi dari setiap connected component penting untuk analisis connectivity graf.</p> <p>Input: - <code>n</code> = jumlah vertex - <code>m</code> = jumlah edge - Diikuti <code>m</code> baris pasangan edge: <code>u v</code></p> <p>Output: - Jumlah connected components - Daftar vertex pada setiap component</p> <p>Contoh Input: <pre><code>6 4\n1 2\n2 3\n4 5\n5 6\n</code></pre></p> <p>Contoh Output: <pre><code>Jumlah connected components: 2\n</code></pre></p>"},{"location":"Topik%20Umum/Graf%20Dasar/03-variasi-umum/#penyelesaian","title":"Penyelesaian","text":"<p>Gunakan DFS untuk menandai setiap vertex yang sudah dikunjungi dan mengelompokkan vertex ke dalam komponen yang sama.</p> Connected Components dengan DFS<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;cstring&gt;\nusing namespace std;\n\nconst int MAXN = 100005;\nvector&lt;int&gt; adj[MAXN];\nbool visited[MAXN];\nint n, m;\n\n// DFS untuk mengumpulkan vertex dalam satu komponen\nvoid dfs(int u) {\n    visited[u] = true;\n    for (int v : adj[u]) {\n        if (!visited[v]) {\n            dfs(v);\n        }\n    }\n}\n\nint main() {\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 0; i &lt; m; i++) {\n        int u, v;\n        cin &gt;&gt; u &gt;&gt; v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    memset(visited, false, sizeof(visited));\n    int ans = 0;\n\n    for (int i = 1; i &lt;= n; i++) {\n        if (!visited[i]) {\n            dfs(i);\n            ans++;\n        }\n    }\n\n    cout &lt;&lt; \"Jumlah connected components: \" &lt;&lt; ans &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"Topik%20Umum/Graf%20Dasar/03-variasi-umum/#kompleksitas-connected-components","title":"Kompleksitas Connected Components","text":"Aspek Kompleksitas Time Complexity O(V + E) Space Complexity O(V)"},{"location":"Topik%20Umum/Graf%20Dasar/03-variasi-umum/#cycle-detection-dengan-dfs-directed-graph","title":"Cycle Detection dengan DFS (Directed Graph)","text":""},{"location":"Topik%20Umum/Graf%20Dasar/03-variasi-umum/#masalah_1","title":"Masalah","text":"<p>Diberikan sebuah directed graph, tentukan apakah terdapat cycle di dalamnya.</p> <p>Input: - <code>n</code> = jumlah vertex - <code>m</code> = jumlah edge - Diikuti <code>m</code> baris pasangan edge: <code>u v</code></p> <p>Output: - \"YES\" jika terdapat cycle - \"NO\" jika tidak ada cycle</p>"},{"location":"Topik%20Umum/Graf%20Dasar/03-variasi-umum/#penyelesaian_1","title":"Penyelesaian","text":"<p>Gunakan DFS dengan dua array: - <code>vis[]</code> untuk menandai node yang sudah dikunjungi - <code>pathDfs[]</code> untuk menandai node yang sedang ada di jalur DFS saat ini</p> <p>Jika saat DFS menemukan node yang sudah ada di <code>pathDfs</code>, berarti terdapat cycle.</p> Cycle Detection - Directed Graph<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nconst int MAXN = 100005;\nvector&lt;int&gt; adj[MAXN];\nbool vis[MAXN], pathDfs[MAXN];\nint n, m;\nbool foundCycle = false;\n\nbool dfs(int cur) {\n    vis[cur] = true;\n    pathDfs[cur] = true;\n\n    for (auto v : adj[cur]) {\n        if (pathDfs[v]) {\n            return true; // Cycle detected\n        }\n        if (!vis[v]) {\n            if (dfs(v)) return true;\n        }\n    }\n    pathDfs[cur] = false;\n    return false;\n}\n\nint main() {\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 0; i &lt; m; i++) {\n        int u, v;\n        cin &gt;&gt; u &gt;&gt; v;\n        adj[u].push_back(v);\n    }\n\n    for (int i = 1; i &lt;= n; i++) {\n        if (!vis[i]) {\n            if (dfs(i)) {\n                cout &lt;&lt; \"YES\" &lt;&lt; endl;\n                return 0;\n            }\n        }\n    }\n    cout &lt;&lt; \"NO\" &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"Topik%20Umum/Graf%20Dasar/03-variasi-umum/#shortest-path-dengan-bfs","title":"Shortest Path dengan BFS","text":""},{"location":"Topik%20Umum/Graf%20Dasar/03-variasi-umum/#masalah_2","title":"Masalah","text":"<p>Diberikan sebuah unweighted graph dengan <code>n</code> vertex dan <code>m</code> edge, carilah jalur terpendek dari node <code>source</code> ke node <code>target</code>. Jika tidak ada jalur, keluarkan <code>-1</code>.</p> <p>Input: - <code>n</code> = jumlah vertex - <code>m</code> = jumlah edge - Diikuti <code>m</code> baris pasangan edge: <code>u v</code> - <code>source</code> dan <code>target</code> (node awal dan tujuan)</p> <p>Output: - Jarak terpendek dari <code>source</code> ke <code>target</code>, atau <code>-1</code> jika tidak ada jalur - Jalur yang dilalui (jika ada)</p>"},{"location":"Topik%20Umum/Graf%20Dasar/03-variasi-umum/#penyelesaian_2","title":"Penyelesaian","text":"<p>Gunakan BFS untuk mencari shortest path pada unweighted graph. BFS menjamin jalur terpendek karena mengeksplorasi vertex berdasarkan jarak minimum dari source. Simpan parent setiap node untuk merekonstruksi jalur.</p> BFS Shortest Path<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;queue&gt;\n#include &lt;algorithm&gt;\n#include &lt;climits&gt;\nusing namespace std;\n\nconst int MAXN = 100005;\nconst int INF = INT_MAX;\n\nvector&lt;int&gt; adj[MAXN];\nint dist[MAXN];\nint parent[MAXN];\n\nint main() {\n    int n, m, source, target;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; source &gt;&gt; target;\n\n    for (int i = 0; i &lt; m; i++) {\n        int u, v;\n        cin &gt;&gt; u &gt;&gt; v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    for (int i = 0; i &lt; MAXN; i++) {\n        dist[i] = INF;\n        parent[i] = -1;\n    }\n\n    queue&lt;int&gt; q;\n    dist[source] = 0;\n    q.push(source);\n\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n\n        for (int v : adj[u]) {\n            if (dist[v] == INF) {\n                dist[v] = dist[u] + 1;\n                parent[v] = u;\n                q.push(v);\n            }\n        }\n    }\n\n    if (dist[target] == INF) {\n        cout &lt;&lt; -1 &lt;&lt; endl;\n    } else {\n        cout &lt;&lt; \"Shortest distance: \" &lt;&lt; dist[target] &lt;&lt; endl;\n        vector&lt;int&gt; path;\n        int cur = target;\n        while (cur != -1) {\n            path.push_back(cur);\n            cur = parent[cur];\n        }\n        reverse(path.begin(), path.end());\n        cout &lt;&lt; \"Path: \";\n        for (int i = 0; i &lt; path.size(); i++) {\n            if (i &gt; 0) cout &lt;&lt; \" -&gt; \";\n            cout &lt;&lt; path[i];\n        }\n        cout &lt;&lt; endl;\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"Topik%20Umum/Graf%20Dasar/03-variasi-umum/#kompleksitas-shortest-path-bfs","title":"Kompleksitas Shortest Path BFS","text":"Aspek Kompleksitas Time Complexity O(V + E) Space Complexity O(V)"},{"location":"Topik%20Umum/Graf%20Dasar/03-variasi-umum/#multi-source-bfs","title":"Multi Source BFS","text":"<p>Multi Source BFS adalah teknik pencarian jalur terpendek dari beberapa titik awal (source) sekaligus dalam sebuah graf.</p>"},{"location":"Topik%20Umum/Graf%20Dasar/03-variasi-umum/#cara-kerja","title":"Cara Kerja","text":"<p>Pada Multi Source BFS, semua node sumber dimasukkan ke dalam queue pada awal proses. BFS kemudian berjalan seperti biasa, namun setiap node yang dikunjungi akan memiliki jarak minimum dari salah satu sumber. Dengan cara ini, kita dapat menghitung jarak terdekat dari semua sumber ke setiap node di graf.</p>"},{"location":"Topik%20Umum/Graf%20Dasar/03-variasi-umum/#implementasi-dasar","title":"Implementasi Dasar","text":"Multi Source BFS<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;queue&gt;\n#include &lt;climits&gt;\nusing namespace std;\n\nconst int MAXN = 100005;\nconst int INF = INT_MAX;\n\nvector&lt;int&gt; adj[MAXN];\nint dist[MAXN];\n\nint main() {\n    int n, m, k;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;\n    vector&lt;int&gt; sources(k);\n    for (int i = 0; i &lt; k; i++) {\n        cin &gt;&gt; sources[i];\n    }\n    for (int i = 0; i &lt; m; i++) {\n        int u, v;\n        cin &gt;&gt; u &gt;&gt; v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    for (int i = 0; i &lt; MAXN; i++) dist[i] = INF;\n    queue&lt;int&gt; q;\n    for (int src : sources) {\n        dist[src] = 0;\n        q.push(src);\n    }\n    while (!q.empty()) {\n        int u = q.front(); q.pop();\n        for (int v : adj[u]) {\n            if (dist[v] == INF) {\n                dist[v] = dist[u] + 1;\n                q.push(v);\n            }\n        }\n    }\n    for (int i = 1; i &lt;= n; i++) {\n        cout &lt;&lt; \"Node \" &lt;&lt; i &lt;&lt; \": \" &lt;&lt; dist[i] &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Topik%20Umum/Graf%20Dasar/03-variasi-umum/#kompleksitas-multi-source-bfs","title":"Kompleksitas Multi Source BFS","text":"Aspek Kompleksitas Time Complexity O(V + E) Space Complexity O(V)"},{"location":"Topik%20Umum/Graf%20Dasar/03-variasi-umum/#contoh-soal-klasik","title":"Contoh Soal Klasik","text":"<ul> <li>CSES Monsters</li> </ul>"},{"location":"Topik%20Umum/Graf%20Dasar/03-variasi-umum/#shortest-path-dengan-path-nya","title":"Shortest Path dengan Path nya","text":"<p>Seringkali dalam pemrograman kompetitif, kita tidak hanya perlu mengetahui jarak terpendek tetapi juga jalur yang dilalui untuk mencapai tujuan tersebut. Teknik ini menggunakan konsep parent tracking untuk merekonstruksi jalur setelah BFS selesai.</p>"},{"location":"Topik%20Umum/Graf%20Dasar/03-variasi-umum/#cara-kerja_1","title":"Cara Kerja","text":"<ol> <li>Simpan Parent: Saat melakukan BFS, simpan informasi parent dari setiap vertex yang dikunjungi</li> <li>Backtrack: Setelah mencapai target, ikuti parent chain dari target kembali ke source</li> <li>Reverse: Karena kita backtrack dari target ke source, reverse hasil untuk mendapatkan jalur yang benar</li> </ol>"},{"location":"Topik%20Umum/Graf%20Dasar/03-variasi-umum/#implementasi-dasar_1","title":"Implementasi Dasar","text":"BFS dengan Path Reconstruction<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;queue&gt;\n#include &lt;algorithm&gt;\n#include &lt;climits&gt;\nusing namespace std;\n\nconst int MAXN = 100005;\nconst int INF = INT_MAX;\n\nvector&lt;int&gt; adj[MAXN];\nint dist[MAXN];\nint parent[MAXN];\n\nint main() {\n    int n, m, source, target;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; source &gt;&gt; target;\n\n    for (int i = 0; i &lt; m; i++) {\n        int u, v;\n        cin &gt;&gt; u &gt;&gt; v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    // Initialize\n    for (int i = 1; i &lt;= n; i++) {\n        dist[i] = INF;\n        parent[i] = -1;\n    }\n\n    queue&lt;int&gt; q;\n    dist[source] = 0;\n    q.push(source);\n\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n\n        // Early termination jika target sudah ditemukan\n        if (u == target) break;\n\n        for (int v : adj[u]) {\n            if (dist[v] == INF) {\n                dist[v] = dist[u] + 1;\n                parent[v] = u;  // Simpan parent\n                q.push(v);\n            }\n        }\n    }\n\n    if (dist[target] == INF) {\n        cout &lt;&lt; \"No path exists\" &lt;&lt; endl;\n    } else {\n        cout &lt;&lt; \"Shortest distance: \" &lt;&lt; dist[target] &lt;&lt; endl;\n\n        // Reconstruct path\n        vector&lt;int&gt; path;\n        int current = target;\n        while (current != -1) {\n            path.push_back(current);\n            current = parent[current];\n        }\n\n        reverse(path.begin(), path.end());\n\n        cout &lt;&lt; \"Path: \";\n        for (int i = 0; i &lt; path.size(); i++) {\n            if (i &gt; 0) cout &lt;&lt; \" -&gt; \";\n            cout &lt;&lt; path[i];\n        }\n        cout &lt;&lt; endl;\n    }\n\n    return 0;\n}\n</code></pre> <p>Contoh Input: <pre><code>5 5 1 5\n1 2\n2 3\n3 5\n1 4\n4 5\n</code></pre></p> <p>Contoh Output: <pre><code>Shortest distance: 3\nPath: 1 -&gt; 4 -&gt; 5\n</code></pre></p>"},{"location":"Topik%20Umum/Graf%20Dasar/03-variasi-umum/#kompleksitas-shortest-path-dengan-path","title":"Kompleksitas Shortest Path dengan Path","text":"Aspek Kompleksitas Time Complexity O(V + E) Space Complexity O(V) Path Reconstruction O(path_length)"},{"location":"Topik%20Umum/Graf%20Dasar/03-variasi-umum/#contoh-soal-klasik_1","title":"Contoh Soal Klasik","text":"<ul> <li>Message Route</li> </ul>"},{"location":"Topik%20Umum/Graf%20Dasar/03-variasi-umum/#kesimpulan","title":"Kesimpulan","text":"<p>Sebenarnya masih banyak yang dapat dibahas disini karena variasi graph cukup banyak dan tidak semua penulis kuasai, web ini akan diupdate jika saya niat hihi.</p>"}]}